
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for NetworkSwitchLevel1.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.2.1
//* Generated on: Aug. 15, 2016 12:15:23 PM, (user: kenm)
//* Automatically merged on: Aug. 15, 2016 10:47:09 PM, (user: kenm)
//* Automatically merged on: Aug. 15, 2016 10:47:54 PM, (user: kenm)
//*>



#include "NetworkSwitchLevel1_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
NetworkSwitchLevel1_pv::NetworkSwitchLevel1_pv(sc_module_name module_name) 
  : NetworkSwitchLevel1_pv_base(module_name) {
  NodeFifo0.set_minimal_delay(WireDelay);
  NodeFifo1.set_minimal_delay(WireDelay);
  NodeFifo2.set_minimal_delay(WireDelay);
  NodeFifo3.set_minimal_delay(WireDelay);
  NodeFifo4.set_minimal_delay(WireDelay);

  SC_THREAD(NodeThread0);
  SC_THREAD(NodeThread1);
  SC_THREAD(NodeThread2);
  SC_THREAD(NodeThread3);
  SC_THREAD(NodeThread4);
}      

// Read callback for NodeSlave0 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave0_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}


// Read callback for NodeSlave1 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave1_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}


// Read callback for NodeSlave2 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave2_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}


// Read callback for NodeSlave3 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave3_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}


// Read callback for NodeSlave4 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave4_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  
  return true;
}

// Write callback for NodeSlave0 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave0_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return send_packet(NodeMaster0_idx, address, data, size);
} 

// Write callback for NodeSlave1 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave1_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return send_packet(NodeMaster1_idx, address, data, size);
} 

// Write callback for NodeSlave2 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave2_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return send_packet(NodeMaster2_idx, address, data, size);
} 

// Write callback for NodeSlave3 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave3_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return send_packet(NodeMaster3_idx, address, data, size); 
} 

// Write callback for NodeSlave4 port.
// Returns true when successful.
bool NetworkSwitchLevel1_pv::NodeSlave4_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return send_packet(NodeMaster4_idx, address, data, size);
} 




unsigned NetworkSwitchLevel1_pv::NodeSlave0_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned NetworkSwitchLevel1_pv::NodeSlave0_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool NetworkSwitchLevel1_pv::NodeSlave0_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}





unsigned NetworkSwitchLevel1_pv::NodeSlave1_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned NetworkSwitchLevel1_pv::NodeSlave1_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool NetworkSwitchLevel1_pv::NodeSlave1_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}





unsigned NetworkSwitchLevel1_pv::NodeSlave2_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned NetworkSwitchLevel1_pv::NodeSlave2_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool NetworkSwitchLevel1_pv::NodeSlave2_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}





unsigned NetworkSwitchLevel1_pv::NodeSlave3_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned NetworkSwitchLevel1_pv::NodeSlave3_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool NetworkSwitchLevel1_pv::NodeSlave3_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}





unsigned NetworkSwitchLevel1_pv::NodeSlave4_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned NetworkSwitchLevel1_pv::NodeSlave4_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool NetworkSwitchLevel1_pv::NodeSlave4_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

 

// in order to minimize merging conflicts, we recommend to add your functions after this comment
bool NetworkSwitchLevel1_pv::send_packet(unsigned long master_port_index, mb_address_type address, unsigned char * data, unsigned int size) {
  if (size > 1526) {
    return false; // packet larger than standard packet (This doesn't support jumbo packets
  }
  ethernet_packet * packet = new ethernet_packet(data, (unsigned short) size);

  // check to see if the source MAC address is in the Map table. If it isn't add it
  std::map<unsigned long, unsigned long>::iterator key_value = MacAddressMap.find(packet->get_mac_source_as_long());
  if (key_value == MacAddressMap.end()) {
    if (MacAddressMap.size() >= MaxMapTableSize) {
      delete packet;
      return false; // exceeded the maximum table size. Note:: A scrubing routine should be added.
    } else {
      MacAddressMap[packet->get_mac_source_as_long()] = master_port_index;
    }
  }

  // If Mac Destination Address of incoming Packet == 0 Then brodcast Packet to everyone.
  if (packet->get_mac_destination_as_long() == 0) {
    if (NodeFifo0.nb_can_put()) {
      ethernet_packet * cloned_packet = packet->clone();
      NodeFifo0.put(cloned_packet);
    } else {
      cout << sc_time_stamp() << "Node 0 Fifo full packet dropped" << endl;
      return false;
    }
    if (NodeFifo1.nb_can_put()) {
      ethernet_packet * cloned_packet = packet->clone();
      NodeFifo1.put(cloned_packet);
    } else {
      cout << sc_time_stamp() << "Node 1 Fifo full packet dropped" << endl;
      return false;
    }
    if (NodeFifo2.nb_can_put()) {
      ethernet_packet * cloned_packet = packet->clone();
      NodeFifo2.put(cloned_packet);
    } else {
      cout << sc_time_stamp() << "Node 2 Fifo full packet dropped" << endl;
      return false;
    }
    if (NodeFifo3.nb_can_put()) {
      ethernet_packet * cloned_packet = packet->clone();
      NodeFifo3.put(cloned_packet);
    } else {
      cout << sc_time_stamp() << "Node 3 Fifo full packet dropped" << endl;
      return false;
    }
    if (NodeFifo4.nb_can_put()) {
      NodeFifo4.put(packet);
    } else {
      cout << sc_time_stamp() << "Node 4 Fifo full packet dropped" << endl;
      return false;
    }
  } else { // else send the packet to the destination port based on the MAC map table.
    key_value = MacAddressMap.find(packet->get_mac_destination_as_long());
    if (key_value == MacAddressMap.end()) {
      cout << "Destination not Mapped, Packet Dropped" << endl;
      delete packet;
    } else {
      unsigned long port_index = key_value->second;
      if (port_index == NodeMaster0_idx) {
        if (NodeFifo0.nb_can_put()) {
          NodeFifo0.put(packet);
        } else {
          cout << sc_time_stamp() << "Node 0 Fifo full packet dropped" << endl;
          return false;
        }
      } else if (port_index == NodeMaster1_idx) {
        if (NodeFifo1.nb_can_put()) {
          NodeFifo1.put(packet);
        } else {
          cout << sc_time_stamp() << "Node 1 Fifo full packet dropped" << endl;
          return false;
        }
      } else if (port_index == NodeMaster2_idx) {
        if (NodeFifo2.nb_can_put()) {
          NodeFifo2.put(packet);
        } else {
          cout << sc_time_stamp() << "Node 2 Fifo full packet dropped" << endl;
          return false;
        }
      } else if (port_index == NodeMaster3_idx) {
        if (NodeFifo3.nb_can_put()) {
          NodeFifo3.put(packet);
        } else {
          cout << sc_time_stamp() << "Node 3 Fifo full packet dropped" << endl;
          return false;
        }
      } else if (port_index == NodeMaster4_idx) {
        if (NodeFifo4.nb_can_put()) {
          NodeFifo4.put(packet);
        } else {
          cout << sc_time_stamp() << "Node 4 Fifo full packet dropped" << endl;
          return false;
        }
      } else {
        delete packet;
      }
    }
  }
  return true;
}

void NetworkSwitchLevel1_pv::NodeThread0() {
  while (true) {
    ethernet_packet * packet = NodeFifo0.get();
    unsigned char * ucpacket = packet->get_packet();

    NodeMaster0_write(packet->get_mac_destination_as_long(), ucpacket, packet->get_packet_size());
    delete ucpacket;
    delete packet;
  }
}

void NetworkSwitchLevel1_pv::NodeThread1() {
  while (true) {
    ethernet_packet * packet = NodeFifo1.get();
    unsigned char * ucpacket = packet->get_packet();

    NodeMaster1_write(packet->get_mac_destination_as_long(), ucpacket, packet->get_packet_size());
    delete ucpacket;
    delete packet;
  }
}

void NetworkSwitchLevel1_pv::NodeThread2() {
  while (true) {
    ethernet_packet * packet = NodeFifo2.get();
    unsigned char * ucpacket = packet->get_packet();

    NodeMaster2_write(packet->get_mac_destination_as_long(), ucpacket, packet->get_packet_size());
    delete ucpacket;
    delete packet;
  }
}

void NetworkSwitchLevel1_pv::NodeThread3() {
  while (true) {
    ethernet_packet * packet = NodeFifo3.get();
    unsigned char * ucpacket = packet->get_packet();

    NodeMaster3_write(packet->get_mac_destination_as_long(), ucpacket, packet->get_packet_size());
    delete ucpacket;
    delete packet;
  }
}

void NetworkSwitchLevel1_pv::NodeThread4() {
  while (true) {
    ethernet_packet * packet = NodeFifo4.get();
    unsigned char * ucpacket = packet->get_packet();

    NodeMaster4_write(packet->get_mac_destination_as_long(), ucpacket, packet->get_packet_size());
    delete ucpacket;
    delete packet;
  }
}
