
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The SensorNodeLevel1_pv will be derived from this class.
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 15, 2016 05:30:52 PM, (user: kenm)
//*>



#pragma once

#include "model_builder.h"
#include "ethernet_packet.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4201 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.2.1. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif




#include "generic_protocol.h"

using namespace ::tlm;

class SensorNodeLevel1_pv_base;
class SensorNodeLevel1_pv_base_mb_compatibility : public mb::mb_module {
  friend class SensorNodeLevel1_pv_base;
 public:
  typedef unsigned int mb_address_type;
 protected:
  SensorNodeLevel1_pv_base_mb_compatibility(sc_core::sc_module_name& module_name)
    : mb::mb_module(module_name) {}

  ////////////////////////////////////////
  // functions for target port: NetworkSlave
  ////////////////////////////////////////
  protected:
   virtual bool NetworkSlave_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   } 
   virtual bool NetworkSlave_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   } 
   virtual unsigned NetworkSlave_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   } 
   virtual unsigned NetworkSlave_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool NetworkSlave_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   } 
};

class SensorNodeLevel1_pv_base_parameters {
 public :
  SensorNodeLevel1_pv_base_parameters(sc_object* object);
  void print_parameters();

 protected:
  sc_object* m_object;

  sc_core::sc_time clock;
  sc_core::sc_time generic_clock;
  double nominal_voltage;
  bool mb_debug;
  bool call_to_default_if;
  bool verbose_parameters;
  bool dmi_enabled;
  const char* warning_level;
  unsigned int NetworkSlave_pipeline_length;
  unsigned int SampleIntervalInClocks;
  unsigned int NumberOfSamplesPerPacket;
  unsigned int MinRetryDelayInClocks;
  unsigned int MaxRetryDelayInClocks;
  unsigned int MaxNumberOfRetrys;
  unsigned int AcknowledgeTimeoutInClocks;
  unsigned long long MacAddress;
  unsigned long long MacAddressSystemController;
  unsigned int TotalNumberOfPackets;
  unsigned int SampleFifoSize;
};

class SensorNodeLevel1_pv_base : public SensorNodeLevel1_pv_base_mb_compatibility,
                           public SensorNodeLevel1_pv_base_parameters
{
 private:
  typedef SensorNodeLevel1_pv_base_mb_compatibility mb_compatibility_class;
  typedef SensorNodeLevel1_pv_base_mb_compatibility BASE_TYPE;
 public:
  typedef esl::tlm_types::Address mb_address_type;
 public:
  typedef SensorNodeLevel1_pv_base self;
  SC_HAS_PROCESS(SensorNodeLevel1_pv_base);
  SensorNodeLevel1_pv_base(sc_core::sc_module_name& module_name);
  virtual void reset_registers();
  virtual void reset_model();
  enum port_enum {Sensor_idx = 0,NetworkMaster_idx = 1,NetworkSlave_idx = 2 };
  
 private:

  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_Sensor_bw_process;
  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_NetworkMaster_bw_process;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_NetworkSlave_fw_process;

 protected:

  virtual void NetworkSlave_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (mb_debug) {
      std::cout.unsetf(std::ios::showbase);
      bool isWrite = trans.is_write();
      unsigned char* data = trans.get_data_ptr();
      sc_dt::uint64 address = trans.get_address();
      unsigned size = trans.get_data_length();
      std::cout << this->name() << "::NetworkSlave_callback_" <<
        (isWrite ? "write" : "read") << ", address = 0x" << std::hex << address;
      if (isWrite) {
        std::cout << ", data = {";
        std::cout << std::hex;
        for (unsigned u=0; u<size; u++) {
          std::cout << "0x" << (unsigned int)(data[u]);
          if (u+1 != size) {
            std::cout << ", ";
          }
        }
        std::cout << std::dec << "}";
      }
      std::cout << ", size = " << std::dec << size << std::endl;
    }
    if (trans.get_byte_enable_ptr() && trans.get_byte_enable_length()) {
      std::stringstream str;
      str << std::showbase << std::hex;
      if (trans.is_write())
        str << "writing to address " << trans.get_address() << " : byte enable pointer defined but not used ";
      else
        str << "reading from address " << trans.get_address() << " : byte enable pointer defined but not used ";
      mb::sysc::complain(str.str().c_str(), this->name());
    }
    payload_for_token = &trans;
    
    if (trans.is_write()) {
      status = NetworkSlave_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = NetworkSlave_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    payload_for_token = 0;

    tlm::tlm_response_status trans_status = trans.get_response_status();
    if (trans_status == tlm::TLM_INCOMPLETE_RESPONSE ||
        trans_status == tlm::TLM_OK_RESPONSE)
      trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned NetworkSlave_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    unsigned status = 0;
    if (trans.is_write()) {
      status = NetworkSlave_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = NetworkSlave_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } 

    return status;
  }

  virtual bool NetworkSlave_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = NetworkSlave_get_direct_memory_ptr(trans.get_address(), dmiData);
    if (ret_value) {
      get_dmi_delay_cb(trans, dmiData, NetworkSlave_idx);
    }
    payload_on_stack = 0;
    return ret_value;
  }

  virtual void get_dmi_delay_cb(tlm::tlm_generic_payload& trans, tlm::tlm_dmi& dmiData, unsigned port_index) {
    sc_time t = sc_core::SC_ZERO_TIME;
    
    getPVTBaseModel()->get_write_delay_for_dmi(port_index, trans, t);
    dmiData.set_write_latency(t);
    t = sc_core::SC_ZERO_TIME;
    getPVTBaseModel()->get_read_delay_for_dmi(port_index, trans, t);
    dmiData.set_read_latency(t);
    
  }

  virtual void invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void Sensor_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void NetworkMaster_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }

  

  



  

  
  

 public:

  ////////////////////////////////////////
  // functions for initiator port: Sensor
  ////////////////////////////////////////
  bool Sensor_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    Sensor->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool Sensor_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool Sensor_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool Sensor_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool Sensor_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool Sensor_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool Sensor_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool Sensor_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool Sensor_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool Sensor_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool Sensor_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool Sensor_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool Sensor_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool Sensor_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool Sensor_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool Sensor_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool Sensor_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool Sensor_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool Sensor_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool Sensor_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool Sensor_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool Sensor_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool Sensor_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool Sensor_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool Sensor_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool Sensor_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool Sensor_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool Sensor_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool Sensor_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool Sensor_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool Sensor_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool Sensor_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool Sensor_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 

  ////////////////////////////////////////
  // functions for initiator port: NetworkMaster
  ////////////////////////////////////////
  bool NetworkMaster_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    NetworkMaster->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool NetworkMaster_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool NetworkMaster_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool NetworkMaster_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool NetworkMaster_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool NetworkMaster_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool NetworkMaster_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool NetworkMaster_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool NetworkMaster_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool NetworkMaster_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool NetworkMaster_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool NetworkMaster_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool NetworkMaster_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool NetworkMaster_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool NetworkMaster_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool NetworkMaster_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool NetworkMaster_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool NetworkMaster_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool NetworkMaster_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool NetworkMaster_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool NetworkMaster_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool NetworkMaster_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool NetworkMaster_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool NetworkMaster_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool NetworkMaster_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool NetworkMaster_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool NetworkMaster_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool NetworkMaster_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool NetworkMaster_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool NetworkMaster_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool NetworkMaster_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool NetworkMaster_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool NetworkMaster_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 



  ///////////////////////////////////////
  // dbg functions for port: Sensor
  /////////////////////////////////////// 
  
  
  unsigned Sensor_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned Sensor_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned Sensor_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned Sensor_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned Sensor_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned Sensor_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned Sensor_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned Sensor_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned Sensor_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned Sensor_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*Sensor[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 

  ///////////////////////////////////////
  // dbg functions for port: NetworkMaster
  /////////////////////////////////////// 
  
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned NetworkMaster_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned NetworkMaster_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned NetworkMaster_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned NetworkMaster_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned NetworkMaster_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned NetworkMaster_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned NetworkMaster_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned NetworkMaster_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned NetworkMaster_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*NetworkMaster[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 


  tlm::tlm_generic_payload* payload_on_stack;
  tlm::tlm_generic_payload* payload_for_token;

  ////////////////////////////////////////
  // request DMI for port: Sensor
  ////////////////////////////////////////
  bool Sensor_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = Sensor->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool Sensor_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = Sensor->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }
  ////////////////////////////////////////
  // request DMI for port: NetworkMaster
  ////////////////////////////////////////
  bool NetworkMaster_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = NetworkMaster->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool NetworkMaster_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = NetworkMaster->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }


  ////////////////////////////////////////
  // functions for target port: NetworkSlave
  ////////////////////////////////////////
  protected:
  virtual bool NetworkSlave_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
    mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->NetworkSlave_callback_read(mb_compatibility_class::mb_address_type(local_address),
                                                        data,
                                                        size);
   }
   virtual bool NetworkSlave_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->NetworkSlave_callback_write(mb_compatibility_class::mb_address_type(local_address),
                                                         data,
                                                         size);
   }

   virtual unsigned NetworkSlave_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->NetworkSlave_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned NetworkSlave_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->NetworkSlave_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool NetworkSlave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->NetworkSlave_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   } 

   
  
  
 

 public:
  typedef tlm::tlm_base_protocol_types Sensor_protocol_types;
  typedef tlm::tlm_base_protocol_types NetworkMaster_protocol_types;
  typedef tlm::tlm_base_protocol_types NetworkSlave_protocol_types;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type Sensor_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type NetworkMaster_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type NetworkSlave_payload_type;

 public:
  // port declarations 

  tlm::tlm_initiator_socket <16, tlm::tlm_base_protocol_types> Sensor;
  tlm::tlm_initiator_socket <8, tlm::tlm_base_protocol_types> NetworkMaster;
  tlm::tlm_target_socket <8, tlm::tlm_base_protocol_types>  NetworkSlave;  

    
 public:
  void send_b_transport(unsigned port_index, tlm::tlm_generic_payload& trans, sc_core::sc_time& t) {
    if (port_index > get_port_count() || !is_master(port_index))
      return;

    if (port_index >= Sensor_idx && port_index <= Sensor_idx)
      return Sensor->b_transport(trans, t);
    if (port_index >= NetworkMaster_idx && port_index <= NetworkMaster_idx)
      return NetworkMaster->b_transport(trans, t);
    return;
    
  }

  unsigned send_transport_dbg(unsigned port_index, tlm::tlm_generic_payload& trans) {
    if (port_index > get_port_count() || !is_master(port_index))
      return 0;

    if (port_index >= Sensor_idx && port_index <= Sensor_idx)
      return Sensor->transport_dbg(trans);
    if (port_index >= NetworkMaster_idx && port_index <= NetworkMaster_idx)
      return NetworkMaster->transport_dbg(trans);
    
    return 0;
  }
  
  

 public:
  mb::mb_token_ptr get_current_token() {
    mb::mb_token_ptr token_ptr = mb_module::get_current_token();
    if (token_ptr)
      return token_ptr;
    if (payload_for_token) {
      mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*payload_for_token);
      if (extension) {
        mb_module::set_current_token(extension->getToken());
        return extension->getToken();
      }
    }
    return 0;
  }
  

 protected:
  mb::mb_variable<sc_dt::uint64> TotalNumberOfSamples;
  mb::mb_variable<sc_dt::uint64> NumberOfSamplesSent;
  mb::mb_variable<sc_dt::uint64> NumberOfLostSamples;
  mb::mb_variable<int> SampleFifoCount;
  mb::mb_fifo<unsigned short> SampleFifo;
};



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The SensorNodeLevel1_t will be derived from this class.
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 15, 2016 05:30:52 PM, (user: kenm)
//*>


#pragma once

#include "model_builder.h"
#include "generic_protocol.h"
 

class SensorNodeLevel1_t_base : public papoulis::SystemCBaseModel {
public:
  static SensorNodeLevel1_t_base* create_t(const char* _name, long simulation);
public:
  SensorNodeLevel1_t_base(sc_core::sc_module_name& module_name, long simulation);
 
  enum port_enum {Sensor = 0, NetworkMaster = 1, NetworkSlave = 2};

protected:
  // The following callbacks are called whenever there is a transaction start or end in the port

  virtual void accept_generic_READ
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 rDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};
  virtual void end_generic_READ
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 rDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};

  virtual void accept_generic_WRITE
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 wDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};
  virtual void end_generic_WRITE
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 wDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) {};


public:
  virtual bool portHasRegisters(unsigned portIndex);
  virtual bool triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans);

  virtual const char* get_library_name() {return "ModelsLevel1";}
  virtual const char* get_model_vendor() {return "Mentor.com";}
  virtual const char* get_model_version() {return "1.0";}

protected:
  /* schedule functions */
  void schedule_generic_READ
    (long port_index,
     sc_dt::uint64 delay,
     long& burst_size,
     esl::include::transaction_power& power , long ADDR, long* rDATA, long PRIORITY, long BURST, long SIZE, long STATUS);
  void schedule_generic_WRITE
    (long port_index,
     sc_dt::uint64 delay,
     long& burst_size,
     esl::include::transaction_power& power , long ADDR, long* wDATA, long PRIORITY, long BURST, long SIZE, long STATUS);
public:
  /* called when "params.m_phase" is sent through the "port_index" port */
  virtual void sent_phase_cb(unsigned port_index,
                             esl::sc_sim::mb_cb_params& params) {
    
  }
                             
  /* called when "params.m_phase" is received by the "port_index" port */
  virtual void received_phase_cb(unsigned port_index,
                                 esl::sc_sim::mb_cb_params& params) {
    
  }

protected:
  friend class SensorNodeLevel1_model;
  
protected:
  // parameters
  sc_core::sc_time clock;
  sc_core::sc_time generic_clock;
  double nominal_voltage;
  bool mb_debug;
  bool call_to_default_if;
  bool verbose_parameters;
  bool dmi_enabled;
  const char* warning_level;
  unsigned int NetworkSlave_pipeline_length;
  unsigned int SampleIntervalInClocks;
  unsigned int NumberOfSamplesPerPacket;
  unsigned int MinRetryDelayInClocks;
  unsigned int MaxRetryDelayInClocks;
  unsigned int MaxNumberOfRetrys;
  unsigned int AcknowledgeTimeoutInClocks;
  unsigned long long MacAddress;
  unsigned long long MacAddressSystemController;
  unsigned int TotalNumberOfPackets;
  unsigned int SampleFifoSize;

protected:
  long m_simulation;

 
public:
  enum variable_enum {TotalNumberOfSamples_idx, NumberOfSamplesSent_idx, NumberOfLostSamples_idx, SampleFifoCount_idx };
protected:
  mb::mb_t_variable<sc_dt::uint64> TotalNumberOfSamples;
  mb::mb_t_variable<sc_dt::uint64> NumberOfSamplesSent;
  mb::mb_t_variable<sc_dt::uint64> NumberOfLostSamples;
  mb::mb_t_variable<int> SampleFifoCount; 
  
  
  

  static const unsigned port_count = 3;
  papoulis::SystemCBaseModel::PortDescription port_descriptions[port_count];
  
  

protected:
  std::vector<esl::sc_sim::pipeline_policy*> m_pipeline_vector;
  std::vector<esl::sc_sim::sequential_policy*> m_sequential_vector;
  std::vector<esl::sc_sim::delay_policy*> m_delay_vector;
  std::vector<esl::sc_sim::uniform_bus_policy*> m_bus_vector;
  std::vector<esl::sc_sim::power_policy*> m_power_vector;
  std::vector<esl::sc_sim::state_power_policy*> m_state_power_vector;
public:
  virtual void update_sync_all();
  virtual void update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle);
  virtual void update_sequential_parameters(esl::sc_sim::sequential_policy* handle);
  virtual void update_delay_parameters(esl::sc_sim::delay_policy* handle);
  virtual void update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle);
  virtual void update_power_parameters(esl::sc_sim::power_policy* handle);
  virtual void update_global_power_parameters(esl::sc_sim::constant_global_power_policy* handle);
  virtual void update_state_power_parameters(esl::sc_sim::state_power_policy* handle);
protected: /* InterfaceFunctions */
  virtual TransactionCallbackFunctionPointer getTransactionCallback(unsigned callbackIndex);
  config::real80 get_state_power();
protected:

  void start_transaction_generic_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void end_transaction_generic_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void start_transaction_generic_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void end_transaction_generic_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for SensorNodeLevel1.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 15, 2016 05:30:52 PM, (user: kenm)
//*>


#pragma once

#include "model_builder.h"



 


// forward declaration for pv class
class SensorNodeLevel1_pv;



using namespace std;

class SensorNodeLevel1_pvt_param_defaults {
  
public:
  SensorNodeLevel1_pvt_param_defaults(const char* hier_name) {

    sc_core::sc_time clock;
    sc_core::sc_time generic_clock;
    double nominal_voltage;
    bool mb_debug;
    bool call_to_default_if;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    unsigned int NetworkSlave_pipeline_length;
    unsigned int SampleIntervalInClocks;
    unsigned int NumberOfSamplesPerPacket;
    unsigned int MinRetryDelayInClocks;
    unsigned int MaxRetryDelayInClocks;
    unsigned int MaxNumberOfRetrys;
    unsigned int AcknowledgeTimeoutInClocks;
    unsigned long long MacAddress;
    unsigned long long MacAddressSystemController;
    unsigned int TotalNumberOfPackets;
    unsigned int SampleFifoSize;
    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    generic_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("generic_clock", clock, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", 1, hier_name);
    mb_debug = ::mb::sysc::sdInitParameter<bool>("mb_debug", false, hier_name);
    call_to_default_if = ::mb::sysc::sdInitParameter<bool>("call_to_default_if", false, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", true, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", true, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", "WARNING", hier_name);
    NetworkSlave_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("NetworkSlave_pipeline_length", 2, hier_name);
    SampleIntervalInClocks = ::mb::sysc::sdInitParameter<unsigned int>("SampleIntervalInClocks", 100, hier_name);
    NumberOfSamplesPerPacket = ::mb::sysc::sdInitParameter<unsigned int>("NumberOfSamplesPerPacket", 10, hier_name);
    MinRetryDelayInClocks = ::mb::sysc::sdInitParameter<unsigned int>("MinRetryDelayInClocks", 10, hier_name);
    MaxRetryDelayInClocks = ::mb::sysc::sdInitParameter<unsigned int>("MaxRetryDelayInClocks", 100, hier_name);
    MaxNumberOfRetrys = ::mb::sysc::sdInitParameter<unsigned int>("MaxNumberOfRetrys", 10, hier_name);
    AcknowledgeTimeoutInClocks = ::mb::sysc::sdInitParameter<unsigned int>("AcknowledgeTimeoutInClocks", 100000, hier_name);
    MacAddress = ::mb::sysc::sdInitParameter<unsigned long long>("MacAddress", 0, hier_name);
    MacAddressSystemController = ::mb::sysc::sdInitParameter<unsigned long long>("MacAddressSystemController", 0, hier_name);
    TotalNumberOfPackets = ::mb::sysc::sdInitParameter<unsigned int>("TotalNumberOfPackets", 100, hier_name);
    SampleFifoSize = ::mb::sysc::sdInitParameter<unsigned int>("SampleFifoSize", 10000000, hier_name);
    ::mb::sysc::sdPropagateParameters();
  }

  SensorNodeLevel1_pvt_param_defaults(const char* hier_name, sc_core::sc_time clock_init, sc_core::sc_time generic_clock_init, double nominal_voltage_init, bool mb_debug_init, bool call_to_default_if_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int NetworkSlave_pipeline_length_init, unsigned int SampleIntervalInClocks_init, unsigned int NumberOfSamplesPerPacket_init, unsigned int MinRetryDelayInClocks_init, unsigned int MaxRetryDelayInClocks_init, unsigned int MaxNumberOfRetrys_init, unsigned int AcknowledgeTimeoutInClocks_init, unsigned long long MacAddress_init, unsigned long long MacAddressSystemController_init, unsigned int TotalNumberOfPackets_init, unsigned int SampleFifoSize_init) {

    sc_core::sc_time clock;
    sc_core::sc_time generic_clock;
    double nominal_voltage;
    bool mb_debug;
    bool call_to_default_if;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    unsigned int NetworkSlave_pipeline_length;
    unsigned int SampleIntervalInClocks;
    unsigned int NumberOfSamplesPerPacket;
    unsigned int MinRetryDelayInClocks;
    unsigned int MaxRetryDelayInClocks;
    unsigned int MaxNumberOfRetrys;
    unsigned int AcknowledgeTimeoutInClocks;
    unsigned long long MacAddress;
    unsigned long long MacAddressSystemController;
    unsigned int TotalNumberOfPackets;
    unsigned int SampleFifoSize;
    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", clock_init, hier_name);
    generic_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("generic_clock", generic_clock_init, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", nominal_voltage_init, hier_name);
    mb_debug = ::mb::sysc::sdInitParameter<bool>("mb_debug", mb_debug_init, hier_name);
    call_to_default_if = ::mb::sysc::sdInitParameter<bool>("call_to_default_if", call_to_default_if_init, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", verbose_parameters_init, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", dmi_enabled_init, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", warning_level_init, hier_name);
    NetworkSlave_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("NetworkSlave_pipeline_length", NetworkSlave_pipeline_length_init, hier_name);
    SampleIntervalInClocks = ::mb::sysc::sdInitParameter<unsigned int>("SampleIntervalInClocks", SampleIntervalInClocks_init, hier_name);
    NumberOfSamplesPerPacket = ::mb::sysc::sdInitParameter<unsigned int>("NumberOfSamplesPerPacket", NumberOfSamplesPerPacket_init, hier_name);
    MinRetryDelayInClocks = ::mb::sysc::sdInitParameter<unsigned int>("MinRetryDelayInClocks", MinRetryDelayInClocks_init, hier_name);
    MaxRetryDelayInClocks = ::mb::sysc::sdInitParameter<unsigned int>("MaxRetryDelayInClocks", MaxRetryDelayInClocks_init, hier_name);
    MaxNumberOfRetrys = ::mb::sysc::sdInitParameter<unsigned int>("MaxNumberOfRetrys", MaxNumberOfRetrys_init, hier_name);
    AcknowledgeTimeoutInClocks = ::mb::sysc::sdInitParameter<unsigned int>("AcknowledgeTimeoutInClocks", AcknowledgeTimeoutInClocks_init, hier_name);
    MacAddress = ::mb::sysc::sdInitParameter<unsigned long long>("MacAddress", MacAddress_init, hier_name);
    MacAddressSystemController = ::mb::sysc::sdInitParameter<unsigned long long>("MacAddressSystemController", MacAddressSystemController_init, hier_name);
    TotalNumberOfPackets = ::mb::sysc::sdInitParameter<unsigned int>("TotalNumberOfPackets", TotalNumberOfPackets_init, hier_name);
    SampleFifoSize = ::mb::sysc::sdInitParameter<unsigned int>("SampleFifoSize", SampleFifoSize_init, hier_name);

    ::mb::sysc::sdPropagateParameters();
    }

  SensorNodeLevel1_pvt_param_defaults(const char* hier_name, std::vector<std::pair<char*, unsigned int> > &change_parameters){

    sc_core::sc_time clock;
    sc_core::sc_time generic_clock;
    double nominal_voltage;
    bool mb_debug;
    bool call_to_default_if;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    unsigned int NetworkSlave_pipeline_length;
    unsigned int SampleIntervalInClocks;
    unsigned int NumberOfSamplesPerPacket;
    unsigned int MinRetryDelayInClocks;
    unsigned int MaxRetryDelayInClocks;
    unsigned int MaxNumberOfRetrys;
    unsigned int AcknowledgeTimeoutInClocks;
    unsigned long long MacAddress;
    unsigned long long MacAddressSystemController;
    unsigned int TotalNumberOfPackets;
    unsigned int SampleFifoSize;
    for (unsigned i =0; i<change_parameters.size(); i++){
      ::mb::sysc::sdInitParameter<unsigned int>(change_parameters[i].first, change_parameters[i].second, hier_name);
    }

    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    generic_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("generic_clock", clock, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", 1, hier_name);
    mb_debug = ::mb::sysc::sdInitParameter<bool>("mb_debug", false, hier_name);
    call_to_default_if = ::mb::sysc::sdInitParameter<bool>("call_to_default_if", false, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", true, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", true, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", "WARNING", hier_name);
    NetworkSlave_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("NetworkSlave_pipeline_length", 2, hier_name);
    SampleIntervalInClocks = ::mb::sysc::sdInitParameter<unsigned int>("SampleIntervalInClocks", 100, hier_name);
    NumberOfSamplesPerPacket = ::mb::sysc::sdInitParameter<unsigned int>("NumberOfSamplesPerPacket", 10, hier_name);
    MinRetryDelayInClocks = ::mb::sysc::sdInitParameter<unsigned int>("MinRetryDelayInClocks", 10, hier_name);
    MaxRetryDelayInClocks = ::mb::sysc::sdInitParameter<unsigned int>("MaxRetryDelayInClocks", 100, hier_name);
    MaxNumberOfRetrys = ::mb::sysc::sdInitParameter<unsigned int>("MaxNumberOfRetrys", 10, hier_name);
    AcknowledgeTimeoutInClocks = ::mb::sysc::sdInitParameter<unsigned int>("AcknowledgeTimeoutInClocks", 100000, hier_name);
    MacAddress = ::mb::sysc::sdInitParameter<unsigned long long>("MacAddress", 0, hier_name);
    MacAddressSystemController = ::mb::sysc::sdInitParameter<unsigned long long>("MacAddressSystemController", 0, hier_name);
    TotalNumberOfPackets = ::mb::sysc::sdInitParameter<unsigned int>("TotalNumberOfPackets", 100, hier_name);
    SampleFifoSize = ::mb::sysc::sdInitParameter<unsigned int>("SampleFifoSize", 10000000, hier_name);  

    ::mb::sysc::sdPropagateParameters();
  }
  
  //void set_clock (

};

class SensorNodeLevel1_pvt : public esl::sc_sim::PVTBaseModel, 
                          public mb::utl::cb_owner,
                          private SensorNodeLevel1_pvt_param_defaults {

 public:
  typedef SensorNodeLevel1_pvt self_type;

 public: 
  // Constructor
  SensorNodeLevel1_pvt(sc_core::sc_module_name module_name); 
  SensorNodeLevel1_pvt(sc_core::sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time generic_clock_init, double nominal_voltage_init, bool mb_debug_init, bool call_to_default_if_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int NetworkSlave_pipeline_length_init, unsigned int SampleIntervalInClocks_init, unsigned int NumberOfSamplesPerPacket_init, unsigned int MinRetryDelayInClocks_init, unsigned int MaxRetryDelayInClocks_init, unsigned int MaxNumberOfRetrys_init, unsigned int AcknowledgeTimeoutInClocks_init, unsigned long long MacAddress_init, unsigned long long MacAddressSystemController_init, unsigned int TotalNumberOfPackets_init, unsigned int SampleFifoSize_init); 
  SensorNodeLevel1_pvt(sc_core::sc_module_name module_name, std::vector<std::pair<char*, unsigned int> > &change_parameters);
  ~SensorNodeLevel1_pvt(); 

 
 public:
    //access the T instance
  inline SensorNodeLevel1_t_base* getT() const {
    return m_SensorNodeLevel1_t;
  }
  
  //access the PV instance
  inline SensorNodeLevel1_pv* getPV() const {
    return m_SensorNodeLevel1_pv;
  }

  virtual const SystemCBaseModel* getSystemCBaseModel() const {
    return getT();
  }
  virtual SystemCBaseModel* getSystemCBaseModel() {
    return getT();
  }
  

 private:
  void bind();
  

  void b_transport_outside_Sensor(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_Sensor(tlm::tlm_generic_payload& p);
  void b_transport_outside_NetworkMaster(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_NetworkMaster(tlm::tlm_generic_payload& p); 

 private:
  
  //T instance
  SensorNodeLevel1_t_base* m_SensorNodeLevel1_t;
  
  //PV instance
  SensorNodeLevel1_pv* m_SensorNodeLevel1_pv;

 public:
  // External ports

  typedef esl::sc_sim::pvt_initiator_socket<16, tlm::tlm_base_protocol_types, 1, sc_core::SC_ONE_OR_MORE_BOUND> Sensor_type;
  Sensor_type Sensor;
  typedef esl::sc_sim::pvt_initiator_socket<8, tlm::tlm_base_protocol_types, 1, sc_core::SC_ONE_OR_MORE_BOUND> NetworkMaster_type;
  NetworkMaster_type NetworkMaster;
  typedef esl::sc_sim::pvt_target_socket<8, tlm::tlm_base_protocol_types, 1, sc_core::SC_ONE_OR_MORE_BOUND> NetworkSlave_type;
  NetworkSlave_type NetworkSlave;

 private:
  // PV connection ports

  typedef mb::tlm20::target_socket_cb<16> Sensor_entry_type;
  Sensor_entry_type Sensor_entry;
  typedef mb::tlm20::target_socket_cb<8> NetworkMaster_entry_type;
  NetworkMaster_entry_type NetworkMaster_entry;
  typedef mb::tlm20::initiator_socket_cb<8> NetworkSlave_entry_type;
  NetworkSlave_entry_type NetworkSlave_entry;      

 public:
  sc_core::sc_time Sensor_time;

  sc_core::sc_time NetworkMaster_time;


 private:

  struct Sensor_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    SensorNodeLevel1_pvt& m_owner;
    
    Sensor_nb_connector(SensorNodeLevel1_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.Sensor.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.Sensor;
    }
  };
  friend struct Sensor_nb_connector;
  Sensor_nb_connector m_Sensor_nb_connector;

  struct NetworkMaster_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    SensorNodeLevel1_pvt& m_owner;
    
    NetworkMaster_nb_connector(SensorNodeLevel1_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.NetworkMaster.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.NetworkMaster;
    }
  };
  friend struct NetworkMaster_nb_connector;
  NetworkMaster_nb_connector m_NetworkMaster_nb_connector;



  struct NetworkSlave_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    SensorNodeLevel1_pvt& m_owner;
    
    NetworkSlave_nb_connector(SensorNodeLevel1_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.NetworkSlave.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.NetworkSlave;
    }
  };
  friend struct NetworkSlave_nb_connector;
  NetworkSlave_nb_connector m_NetworkSlave_nb_connector;

  

  tlm::tlm_sync_enum receive_nb_transport_Sensor(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(0, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_NetworkMaster(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(1, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_NetworkSlave(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(2, trans, phase, t);
  }

};



