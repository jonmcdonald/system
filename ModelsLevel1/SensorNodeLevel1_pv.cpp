
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for SensorNodeLevel1.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.2.1
//* Generated on: Aug. 15, 2016 12:15:59 PM, (user: kenm)
//*>



#include "SensorNodeLevel1_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
SensorNodeLevel1_pv::SensorNodeLevel1_pv(sc_module_name module_name) 
  : SensorNodeLevel1_pv_base(module_name) {
  SampleFifo.nb_bound(SampleFifoSize);
  SC_THREAD(IntervalSampleThread);
  SC_THREAD(MainThread);  
}      

// Read callback for NetworkSlave port.
// Returns true when successful.
bool SensorNodeLevel1_pv::NetworkSlave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
}

// Write callback for NetworkSlave port.
// Returns true when successful.
bool SensorNodeLevel1_pv::NetworkSlave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  ethernet_packet * packet = new ethernet_packet(data, (unsigned short)size);
  packet->print();
  if ((packet->get_mac_source_as_long() == MacAddressSystemController) && (packet->get_payload_size() == 2)) {
    AcknowledgeMessageReceived = true;
    AcknowledgeEvent.notify(SC_ZERO_TIME);
  }
  return true;
} 




unsigned SensorNodeLevel1_pv::NetworkSlave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned SensorNodeLevel1_pv::NetworkSlave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool SensorNodeLevel1_pv::NetworkSlave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

 

// in order to minimize merging conflicts, we recommend to add your functions after this comment
void SensorNodeLevel1_pv::IntervalSampleThread() {
  unsigned int ntotal =  TotalNumberOfPackets * NumberOfSamplesPerPacket;
  for (unsigned int ninterval = 0; ninterval < ntotal; ninterval++) {
    unsigned short sample = 0;

    wait(SampleIntervalInClocks * clock);

    mb::mb_token_ptr TokenID = new mb::mb_token();
    set_current_token (TokenID);
    mb_sync();
    TokenID->setField("StartTimeDouble", sc_time_stamp().to_double());
    
    Sensor_read(0, (unsigned char *) &sample, 2);
    SampleFifo.put(sample);
    SampleFifoCount = SampleFifo.used() + 1; // adding 1 because of SystemC update delay.
    
    TotalNumberOfSamples = TotalNumberOfSamples + 1;
  }
}

void SensorNodeLevel1_pv::MainThread() {
  unsigned short * samples = new unsigned short [NumberOfSamplesPerPacket];
  unsigned char * ucsample = (unsigned char *) samples;

  ethernet_packet * dummy_packet = new ethernet_packet();
  dummy_packet->set_mac_destination((unsigned long)0);
  dummy_packet->set_mac_source(MacAddress);
  dummy_packet->set_payload_size(0);
  dummy_packet->calc_fcr();
  mb_sync();
  dummy_packet->time_stamp = sc_time_stamp();

  unsigned char * ucdummy_packet = dummy_packet->get_packet();
  NetworkMaster_write(0, ucdummy_packet, dummy_packet->get_packet_size());
  delete ucdummy_packet;
  delete dummy_packet;
  

  for (unsigned int npacket = 0; npacket < TotalNumberOfPackets; npacket++) {
    double sample_start_time = -1;

    for (unsigned int nsample = 0; nsample < NumberOfSamplesPerPacket; nsample++) {
      unsigned short sample;

      sample = SampleFifo.get();
      samples[nsample] = sample;

      mb::mb_token_ptr TokenID;
      if (sample_start_time < 0) {
        if (TokenID = get_current_token()) {
          if (TokenID->hasField("StartTimeDouble")) {
            sample_start_time = TokenID->getFieldAsDouble("StartTimeDouble");
          }
        }
      }
      
      if (!(TokenID = get_current_token())) {
        mb::mb_token_ptr TokenID = new mb::mb_token();
      }
      TokenID->setField("StartTimeDouble", sample_start_time);        
    }

    ethernet_packet * packet = new ethernet_packet();
    packet->set_mac_destination(MacAddressSystemController);
    packet->set_mac_source(MacAddress);
    packet->set_payload_size((unsigned short)(NumberOfSamplesPerPacket * sizeof(unsigned short)));
    packet->set_payload(ucsample);
    packet->calc_fcr();
    mb_sync();
    packet->time_stamp = sc_time_stamp();

    unsigned char * ucpacket = packet->get_packet();

    for (unsigned int ntry = 0; ntry < MaxNumberOfRetrys; ntry++) {
      NetworkMaster_write(MacAddressSystemController, ucpacket, packet->get_packet_size());
      wait(AcknowledgeTimeoutInClocks * clock, AcknowledgeEvent);
      if (AcknowledgeMessageReceived) {
        NumberOfSamplesSent = NumberOfSamplesSent + 10;
        NumberOfLostSamples = TotalNumberOfSamples - (NumberOfSamplesSent + 10);
        break;
      }
    }
    if (!AcknowledgeMessageReceived) {
      cout << sc_time_stamp() << " " << name() << " ERROR: Packet Lost *******************" << endl;
      AcknowledgeMessageReceived = false;
    }
    delete ucpacket;
    delete packet;
  }
}

