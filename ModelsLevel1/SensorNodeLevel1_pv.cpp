
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for SensorNodeLevel1.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.2.1
//* Generated on: Aug. 15, 2016 12:15:59 PM, (user: kenm)
//*>



#include "SensorNodeLevel1_pv.h"
#include <iostream>
#include <stdlib.h>
#include <assert.h>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
SensorNodeLevel1_pv::SensorNodeLevel1_pv(sc_module_name module_name) 
  : SensorNodeLevel1_pv_base(module_name),
    RetryPacketQ("RetryPacketQ")
{

  ReturnPacketQ.nb_bound(8);
  RetryPacketQ.nb_bound(8);
  SampleFifo.nb_bound(SampleFifoSize); // set the size of the Sample Fifo
  SentPacketQ.nb_bound(1000);
  SentPacketQ.set_minimal_delay(AcknowledgeTimeoutInClocks * clock);

  SC_THREAD(IntervalSampleThread);     // Responsible for getting samples and sending to MainThread
  SC_THREAD(MainThread);               // Responsible for getting samples, and retry requests and sending out packets
  SC_THREAD(AckThread);                // Responsible for receiving packet ack and packet timeouts, sends retry request

  RetryPacketRate = 0;
  DropPacketRate = 0;
  DropSampleRate = 0;
  sentPackets = 0;
  preceived = 0;
  pdropped = 0;
  pretried = 0;
}      

// Read callback for NetworkSlave port.
// Returns true when successful.
bool SensorNodeLevel1_pv::NetworkSlave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  // READ NOT USED
  return true;
}

// Write callback for NetworkSlave port.
// Returns true when successful.
bool SensorNodeLevel1_pv::NetworkSlave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {

  mb::mb_token_ptr token = get_current_token();
  assert (token->hasField("PacketID"));
  unsigned int id = token->getFieldAsUInt("PacketID");

  // convert incoming data to a ethernet packet object
  ethernet_packet * packet = new ethernet_packet(data, (unsigned short)size);
  
  // check for valid MAC addresses ( > 0 )
  if (packet->getMacDestination() != MacAddress ) {
    delete packet; // delete unused packet object
    return true;
  }
  // Check to see if the Source MAC is the SystemController and the payload size is 2
  if ((packet->getMacSource() == MacAddressSystemController) && (packet->getPayloadSize() == 2)) {
    // Indicate a Acknowledgement is being received
    ReturnPacketQ.put(packet);

  }
  return true;
} 

unsigned SensorNodeLevel1_pv::NetworkSlave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned SensorNodeLevel1_pv::NetworkSlave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool SensorNodeLevel1_pv::NetworkSlave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

 

// in order to minimize merging conflicts, we recommend to add your functions after this comment

// Interval Timer thread
void SensorNodeLevel1_pv::IntervalSampleThread() {
  mb_distribution *sampleDist = mb_CreateDistribution(SampleDistribution);

  unsigned int ntotal =  TotalNumberOfPackets * NumberOfSamplesPerPacket; // calculate the total number of samples

  wait( ((rand() % (MaxRetryDelayInClocks-MinRetryDelayInClocks)) + MinRetryDelayInClocks) * clock);

  for (unsigned int ninterval = 0; ninterval < ntotal; ninterval++) { // loop for the total number of samples
    unsigned short sample = 0; // variable to hold the sample

    wait(sampleDist->getNextInt() * clock); // wait for intervel period

    // Saves the time for which the sample data was creation (using Tokens)
    // this allows the time stamp to be passed along with the data behide the sense
    // This is used for verification and analysis
    mb::mb_token_ptr current_token = new mb::mb_token(); // create the current token
    set_current_token(current_token);   // set a new token
    
    mb_sync();                                                      // upate the system time
    // add a new vlaue to the token for the time stamp
    current_token->setField("StartTimeNS", (unsigned int)(sc_time_stamp()/sc_time(1, SC_NS)) ); 
    
    // read data from the sensor threw the sensor port
    Sensor_read(0, (unsigned char *) &sample, 2);                     // read two charactors and conver them to an unsigned short
    if (SampleFifo.nb_can_put()) {                                    // check to see if there is room in the fifo
      DropSampleRate = 0.8 * DropSampleRate;
      SampleFifo.put(sample);                                         // add the sample to the fifo if space is availible
      //      SampleFifoCount = SampleFifo.used() + 1;                            // adding 1 because of SystemC update delay.
    } else {                                                          // if no room if fifo drop the sample
      DropSampleRate = 0.8 * DropSampleRate + 20;
      SampleDroppedCount = SampleDroppedCount + 1;                    // count the dropped samples
    }
    
    TotalNumberOfSamples = TotalNumberOfSamples + 1;                  // tract the totalNumber of Samples
  }
}

// Main thread which gather samples from the sample Fifo and sends them out into the network.
void SensorNodeLevel1_pv::MainThread() {

  mb::mb_token_ptr current_token;
  unsigned int nsample = 0;
  unsigned short sample;
  unsigned int id;
  ethernet_packet * packet;

  // A array to hold a predefined number of samples to be sent
  unsigned short * samples;

  // loop for sending a  predefined number od sample packets.
  for (;;) {

    if (RetryPacketQ.nb_get(id))   // We have a packet to send again from the retry queue
    {
      if (OutstandingPackets.count(id) == 1) {
        pretried++;
        RetryPacketRate = (0.8 * RetryPacketRate) + 20;
        packet = OutstandingPackets[id]->packetptr;
        SentPacketQ.nb_put(id);
        NetworkMaster_write(MacAddressSystemController, (unsigned char *) packet, packet->getPacketSize());
      }
    }
    else if (SampleFifo.nb_get(sample)) // We have a new sample
    {
      if (nsample == 0)  // The first sample of the set
      {
        samples = new unsigned short [NumberOfSamplesPerPacket];
        current_token = get_current_token(); // Save the current token from the first sample, this has the initial StartTime for the set
      }
      samples[nsample++] = sample;               // add new sample from fifo to sample arraay
      if (nsample == NumberOfSamplesPerPacket)   // The packet is full, ready to send
      {
        nsample = 0;

        // Ready to send the packet.  Check to see if we have room to save in the outstanding packet before creating it
        if (OutstandingPackets.size() <= MaxOutstandingPackets)
        {
          set_current_token(current_token);   // Set the current token to the first token of the set

          id = ++sentPackets;
          current_token->setField("PacketID", id);               // Set ID used to identify returned packet
          // Create a new packet for sending the samples
          packet = new ethernet_packet();
    
          packet->setMacDestination(MacAddressSystemController); // set the Destination mac address    
          packet->setMacSource(MacAddress);                      // Set the source mac address for the packet.
          packet->setPayloadSize((unsigned short)(NumberOfSamplesPerPacket * sizeof(unsigned short))); // set packet data size
          packet->setPayload((unsigned char *) samples);            // set data (unsigned char)
          packet->calcFcr();                                     // Calculate error correction and detection and add to packet

          OutstandingPackets[id] = new PacketTransType(current_token, packet, 1);  // Save the packet for the AckThread
          SentPacketQ.put(id);                     // Used to synchronize with receive thread and limit outstanding packets

          NetworkMaster_write(MacAddressSystemController, (unsigned char *) packet, packet->getPacketSize()); // send packet of samples
        }
        else // If not the packet is dropped because too many are already outstanding.
        {
          pdropped++;
          DropPacketRate = 0.8 * DropPacketRate + 20;
          delete samples;
        }
      }
    }
    else // Wait for something to do
    {
      wait (RetryPacketQ.ok_to_get() | SampleFifo.ok_to_get() );
    }
  }
}

// Thread to handle acknowledge of packets coming back
void SensorNodeLevel1_pv::AckThread() {
  
  ethernet_packet *packet;
  unsigned int id;
  mb::mb_token_ptr token;
  sc_time start_time, delta_time;

    for (;;) {

      if (ReturnPacketQ.nb_get(packet))  // A packet has come back
      {
        preceived++;
        token = get_current_token();
        assert (token->hasField("PacketID"));
        id = token->getFieldAsUInt("PacketID");
        if (OutstandingPackets.count(id) == 0)  // Packet returned beyond retry count or earlier try already returned
        {
          continue;
        } 
        else                                    // Packet received, log success and clear from OutstandingPackets
        {
          assert (token->hasField("StartTimeNS"));
          TimeOfFlightInNanoSeconds = (sc_time_stamp() / sc_time(1, SC_NS)) - token->getFieldAsDouble("StartTimeNS");
          DropPacketRate = 0.8 * DropPacketRate;
          RetryPacketRate = 0.8 * RetryPacketRate;
          OutstandingPackets.erase(id);
        }
      }
      else if (SentPacketQ.nb_get(id))   // Timeout for packet id has occured check that it has been received or resend
      {
        if (OutstandingPackets.count(id) == 0) // Packet was already cleared
        {
          continue;
        }
        else if (OutstandingPackets[id]->retryCount++ <= MaxNumberOfRetrys)  // Retry packet
        {
          if (not RetryPacketQ.nb_put(id))
          {
            pdropped++;
            DropPacketRate = 0.8 * DropPacketRate + 20;
            OutstandingPackets.erase(id);
          }
        } 
        else  // Packet retry exceeded, log failure
        {
          pdropped++;
          DropPacketRate = 0.8 * DropPacketRate + 20;
          OutstandingPackets.erase(id);
        }
      } 
      else   // Wait until we have something to do
      {
        wait (ReturnPacketQ.ok_to_get() | SentPacketQ.ok_to_get() );
      }
    }
}

void SensorNodeLevel1_pv::end_of_simulation()
{
  cout<<name()<<": "<<sentPackets<<" packets sent, "<<pretried<<" retried, "<<pdropped<<" dropped, "<<preceived<<" received\n";
}
