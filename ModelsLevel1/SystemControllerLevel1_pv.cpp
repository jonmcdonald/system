
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for SystemControllerLevel1.
//* This is a template file: You may modify this file to implement the 
//* behavior of your component. 
//* 
//* Model Builder version: 4.2.1
//* Generated on: Aug. 15, 2016 12:30:04 PM, (user: kenm)
//*>



#include "SystemControllerLevel1_pv.h"
#include <iostream>

using namespace sc_core;
using namespace sc_dt;
using namespace std;

//constructor
SystemControllerLevel1_pv::SystemControllerLevel1_pv(sc_module_name module_name) 
  : SystemControllerLevel1_pv_base(module_name),
  Utilization("Utilization", 0)
{
  ProcessFifo.set_minimal_delay(ProcessDelayInClocks *clock); // sets the processing delay for the packet
  ProcessFifo.nb_bound(ProcessFifoSize);  // sets the size of the System Controller fifo
  max_sample = 0;                         // sets the maximum stample valaue (for all samples to the lowest value)
  min_sample = USHRT_MAX;                 // sets the minimum stample valaue (for all samples to the highest value)

  SC_THREAD(ProcessThread);               // starts the main process thread

  PortWidthFactor = getSystemCBaseModel()->get_port_width(Slave_idx) * 8;          // Used to calculate timing on port
  PortClock = sc_time(1, SC_PS) * getSystemCBaseModel()->get_clock(Slave_idx) ;

  Utilization.setSampling(sc_time(50, SC_US), saAttribute_Sample_TWAvg);   // Record time weighted average utilization in 50 us window
}      

// Read callback for Slave port.
// Returns true when successful.
bool SystemControllerLevel1_pv::Slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  // READ NOT USED
  return true;
}

// Write callback for Slave port.
// Returns true when successful.
bool SystemControllerLevel1_pv::Slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {

  unsigned int t = size * PortWidthFactor;
  wait( t * PortClock );            // Wait here does not drop the packet until after it is fully recieved
                                    // To drop the packet immediately if the fifo is full move the wait to before the put
  ethernet_packet * packet = new ethernet_packet(data, (unsigned short)size);  // create a new packet object for the received data

  // ignore packets to itself or source or destimation of Zero
  if ((packet->getMacSource() != MacAddress) && (packet->getMacSource() > 0 ) && (packet->getMacDestination() > 0)) {
    if (ProcessFifo.nb_can_put()) { // check to see if the fifo has space for the new data
      ProcessFifo.put(packet);      // if there is space add it to the fifo
      pprocessed++;
      return true;                  // return true and exit for callback
    } else {
      pdropped++;
    }
  }
    
  delete packet;                   // delete the newly unused packet
  return false;                    // return packet falure
} 




unsigned SystemControllerLevel1_pv::Slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned SystemControllerLevel1_pv::Slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool SystemControllerLevel1_pv::Slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

 

// in order to minimize merging conflicts, we recommend to add your functions after this comment

// Main processing thread
void SystemControllerLevel1_pv::ProcessThread() {
  unsigned int id;

  // loop for every waiting for packets
  while (true) {
    if (ProcessFifo.used() == 0) Utilization = 0.0;
    ethernet_packet *  packet = ProcessFifo.get();               // get next packet form fifo
    Utilization = 100.0;

    unsigned long mac_source = packet->getMacSource();           // get source mac addres (used as the Acknowledgement destimation address)
    unsigned char * ucsamples = packet->getPayload();            // get packet sample data as unsigned char
    unsigned short * samples = (unsigned short *) ucsamples;     // point to samples as an array of unsigned short integers (16-bit)

    unsigned int nosamples = (unsigned int)(packet->getPayloadSize() / 2); // number of sample = half the size of the payload size
    for (unsigned int nsample = 0; nsample < nosamples; nsample++) { // loop for the number of samples
      if (samples[nsample] > max_sample) {                         // check to see if it is the largesst sample value
        max_sample = samples[nsample];
      } 
      if (samples[nsample] < min_sample) {                         // check to see if it is the smallets sample value
        min_sample = samples[nsample];
      }
    }

    unsigned short offset = (max_sample - min_sample) / 2;       // caclulate a new offset value
    unsigned char * ucoffset = (unsigned char *) &offset;        // point to the offset value as unsigned char array

    delete samples;    // delete samples array payload from received packet
    delete packet;     // delete received packet

    if (mac_source == MacAddress) { // validate mac source address
      cout << sc_time_stamp() << " Destination and source mac address match ....DAB" << endl;
    } else {
      packet = new ethernet_packet(mac_source, MacAddress, (unsigned char *) ucoffset, 2); // create new packet

      unsigned char * ucpacket = packet->getPacket();                                     // set packet payload to offset
      Master_write(mac_source, ucpacket, packet->getPacketSize());                       // send packet 

      delete packet;                                                                       // delete packet
      delete ucpacket;                                                                     // delete unsigned char array version of packet
    }
  }
}

void SystemControllerLevel1_pv::end_of_simulation() {
  cout <<name()<<": "<<pprocessed<<" packets processed, "<<pdropped<<" dropped\n";
}
