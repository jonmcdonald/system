
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The SensorNodeLevel1_pv will be derived from this class.
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 17, 2016 01:56:50 AM, (user: kenm)
//*>


#include "SensorNodeLevel1_model.h"
#include "ethernet_packet.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4201 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.2.1. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


SensorNodeLevel1_pv_base::SensorNodeLevel1_pv_base(sc_module_name& module_name) : 
  SensorNodeLevel1_pv_base_mb_compatibility(module_name),
  SensorNodeLevel1_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(Sensor),
  VISTA_MB_PV_INIT_MEMBER(NetworkMaster),
  VISTA_MB_PV_INIT_MEMBER(NetworkSlave),
  VISTA_MB_PV_INIT_MEMBER(TotalNumberOfSamples),
  VISTA_MB_PV_INIT_MEMBER(NumberOfSamplesSent),
  VISTA_MB_PV_INIT_MEMBER(NumberOfLostSamples),
  VISTA_MB_PV_INIT_MEMBER(SampleFifoCount),
  VISTA_MB_PV_INIT_MEMBER(SampleDroppedCount),
  VISTA_MB_PV_INIT_MEMBER(TimeOfFlightInNanoSeconds) {
  

  // Sensor - not a vector port
  // NetworkMaster - not a vector port
  // NetworkSlave - not a vector port
  unsigned u = 0;


  payload_on_stack = 0;
  payload_for_token = 0;
  reset_registers();
  
  // reset value for output signals

  // reset value for input signals

  // NetworkSlave bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(NetworkSlave);
  // Sensor bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(Sensor);
  // NetworkMaster bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(NetworkMaster);
  // NetworkSlave bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(NetworkSlave);
  // Sensor bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(Sensor);
  // NetworkMaster bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(NetworkMaster);

}

void SensorNodeLevel1_pv_base::reset_registers() {
  // reset all registers
  unsigned u = 0;


}

void SensorNodeLevel1_pv_base::reset_model() {
  
  reset_registers();
  // reset value for output signals

  // reset value for input signals

}

SensorNodeLevel1_pv_base_parameters::SensorNodeLevel1_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, generic_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mb_debug, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, call_to_default_if, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, NetworkSlave_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, SampleIntervalInClocks, 200),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, NumberOfSamplesPerPacket, 10),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, MinRetryDelayInClocks, 10),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, MaxRetryDelayInClocks, 100),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, MaxNumberOfRetrys, 10),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, AcknowledgeTimeoutInClocks, 100000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, MacAddress, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, MacAddressSystemController, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, TotalNumberOfPackets, 100),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, SampleFifoSize, 10000000)
{
  if(verbose_parameters) print_parameters();
}

void SensorNodeLevel1_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\tgeneric_clock = " << generic_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tmb_debug = " << mb_debug << "\n";
  std::cout << "\tcall_to_default_if = " << call_to_default_if << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tNetworkSlave_pipeline_length = " << NetworkSlave_pipeline_length << "\n";
  std::cout << "\tSampleIntervalInClocks = " << SampleIntervalInClocks << "\n";
  std::cout << "\tNumberOfSamplesPerPacket = " << NumberOfSamplesPerPacket << "\n";
  std::cout << "\tMinRetryDelayInClocks = " << MinRetryDelayInClocks << "\n";
  std::cout << "\tMaxRetryDelayInClocks = " << MaxRetryDelayInClocks << "\n";
  std::cout << "\tMaxNumberOfRetrys = " << MaxNumberOfRetrys << "\n";
  std::cout << "\tAcknowledgeTimeoutInClocks = " << AcknowledgeTimeoutInClocks << "\n";
  std::cout << "\tMacAddress = " << MacAddress << "\n";
  std::cout << "\tMacAddressSystemController = " << MacAddressSystemController << "\n";
  std::cout << "\tTotalNumberOfPackets = " << TotalNumberOfPackets << "\n";
  std::cout << "\tSampleFifoSize = " << SampleFifoSize << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The SensorNodeLevel1_t will be derived from this class.
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 17, 2016 01:56:50 AM, (user: kenm)
//*>




#include "SensorNodeLevel1_model.h"
#include <math.h>
#include <stdlib.h>

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;


void SensorNodeLevel1_t_base::schedule_generic_READ
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long ADDR, long* rDATA, long PRIORITY, long BURST, long SIZE, long STATUS) {
  sc_dt::uint64 local_address = 0;
  local_address = ADDR,
  scheduleGenericTransaction(port_index,
                             0,
                             local_address,
                             (unsigned char*)rDATA,
                             transactionSize,
                             SIZE,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

void SensorNodeLevel1_t_base::schedule_generic_WRITE
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long ADDR, long* wDATA, long PRIORITY, long BURST, long SIZE, long STATUS) {
  sc_dt::uint64 local_address = 0;
  local_address = ADDR,
  scheduleGenericTransaction(port_index,
                             1,
                             local_address,
                             (unsigned char*)wDATA,
                             transactionSize,
                             SIZE,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}



void SensorNodeLevel1_t_base::start_transaction_generic_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  
  this->accept_generic_READ
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5]);
}

void SensorNodeLevel1_t_base::end_transaction_generic_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  
  this->end_generic_READ
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5]);
}
void SensorNodeLevel1_t_base::start_transaction_generic_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  
  this->accept_generic_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5]);
}

void SensorNodeLevel1_t_base::end_transaction_generic_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  
  this->end_generic_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5]);
}

SensorNodeLevel1_t_base::TransactionCallbackFunctionPointer SensorNodeLevel1_t_base::getTransactionCallback(unsigned callbackIndex) {
  static TransactionCallbackFunctionPointer funcArray[] = {
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::start_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::start_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::start_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::start_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::start_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::start_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::end_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::end_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::end_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::end_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::end_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&SensorNodeLevel1_t_base::end_transaction_generic_WRITE),
    0
  };
  if(callbackIndex >= sizeof(funcArray) / sizeof(*funcArray) - 1)
    return 0;
  return funcArray[callbackIndex];
}

config::real80 SensorNodeLevel1_t_base::get_state_power() { 
  config::real80 power_value = 0;

  

  return power_value;
}

SensorNodeLevel1_t_base::SensorNodeLevel1_t_base(sc_module_name& module_name, long simulation) :
  papoulis::SystemCBaseModel(module_name),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(generic_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(mb_debug, false),
  SD_INITIALIZE_PARAMETER(call_to_default_if, false),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(NetworkSlave_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(SampleIntervalInClocks, 200),
  SD_INITIALIZE_PARAMETER(NumberOfSamplesPerPacket, 10),
  SD_INITIALIZE_PARAMETER(MinRetryDelayInClocks, 10),
  SD_INITIALIZE_PARAMETER(MaxRetryDelayInClocks, 100),
  SD_INITIALIZE_PARAMETER(MaxNumberOfRetrys, 10),
  SD_INITIALIZE_PARAMETER(AcknowledgeTimeoutInClocks, 100000),
  SD_INITIALIZE_PARAMETER(MacAddress, 0),
  SD_INITIALIZE_PARAMETER(MacAddressSystemController, 0),
  SD_INITIALIZE_PARAMETER(TotalNumberOfPackets, 100),
  SD_INITIALIZE_PARAMETER(SampleFifoSize, 10000000),
  m_simulation(simulation),
  TotalNumberOfSamples("TotalNumberOfSamples", this),
  NumberOfSamplesSent("NumberOfSamplesSent", this),
  NumberOfLostSamples("NumberOfLostSamples", this),
  SampleFifoCount("SampleFifoCount", this),
  SampleDroppedCount("SampleDroppedCount", this),
  TimeOfFlightInNanoSeconds("TimeOfFlightInNanoSeconds", this)
{
  bool separate_read_channel = false;  
  bool separate_write_channel = false;
  char* buffer = 0;
  unsigned port_index = 0;
  
  fix_clock_parameter(generic_clock, "generic_clock");
    separate_read_channel = false;
    separate_write_channel = false;
    buffer = new char[16];
    sprintf(buffer, "Sensor");
    port_index = Sensor;
    port_descriptions[port_index].port_name = buffer;
    port_descriptions[port_index].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
    if (separate_write_channel && separate_read_channel)
      port_descriptions[port_index].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
    port_descriptions[port_index].is_read_write_address_channel = 0;
    
    port_descriptions[port_index].is_read_write_address_channel = 1;
    port_descriptions[port_index].is_master_port = 1;
    port_descriptions[port_index].is_signal_port = 0;
    port_descriptions[port_index].port_width = ((16 + 7) >> 3);
    port_descriptions[port_index].port_width_in_bits = 16;
    port_descriptions[port_index].protocol_name = "generic";
    port_descriptions[port_index].ipxactBusDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactBusDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactBusDef.name = "generic";
    port_descriptions[port_index].ipxactBusDef.version = "1.0"; 
    port_descriptions[port_index].ipxactAbstrDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactAbstrDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactAbstrDef.name = "generic_tlm20";
    port_descriptions[port_index].ipxactAbstrDef.version = "1.0";
    port_descriptions[port_index].port_must_bind = 1;
    port_descriptions[port_index].params_count = 6 + 10;
    port_descriptions[port_index].clock = generic_clock;
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  
  
  fix_clock_parameter(generic_clock, "generic_clock");
    separate_read_channel = false;
    separate_write_channel = false;
    buffer = new char[23];
    sprintf(buffer, "NetworkMaster");
    port_index = NetworkMaster;
    port_descriptions[port_index].port_name = buffer;
    port_descriptions[port_index].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
    if (separate_write_channel && separate_read_channel)
      port_descriptions[port_index].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
    port_descriptions[port_index].is_read_write_address_channel = 0;
    
    port_descriptions[port_index].is_read_write_address_channel = 1;
    port_descriptions[port_index].is_master_port = 1;
    port_descriptions[port_index].is_signal_port = 0;
    port_descriptions[port_index].port_width = ((8 + 7) >> 3);
    port_descriptions[port_index].port_width_in_bits = 8;
    port_descriptions[port_index].protocol_name = "generic";
    port_descriptions[port_index].ipxactBusDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactBusDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactBusDef.name = "generic";
    port_descriptions[port_index].ipxactBusDef.version = "1.0"; 
    port_descriptions[port_index].ipxactAbstrDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactAbstrDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactAbstrDef.name = "generic_tlm20";
    port_descriptions[port_index].ipxactAbstrDef.version = "1.0";
    port_descriptions[port_index].port_must_bind = 1;
    port_descriptions[port_index].params_count = 6 + 10;
    port_descriptions[port_index].clock = generic_clock;
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  
  
  fix_clock_parameter(generic_clock, "generic_clock");
    separate_read_channel = false;
    separate_write_channel = false;
    buffer = new char[22];
    sprintf(buffer, "NetworkSlave");
    port_index = NetworkSlave;
    port_descriptions[port_index].port_name = buffer;
    port_descriptions[port_index].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
    if (separate_write_channel && separate_read_channel)
      port_descriptions[port_index].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
    port_descriptions[port_index].is_read_write_address_channel = 0;
    
    port_descriptions[port_index].is_read_write_address_channel = 1;
    port_descriptions[port_index].is_master_port = 0;
    port_descriptions[port_index].is_signal_port = 0;
    port_descriptions[port_index].port_width = ((8 + 7) >> 3);
    port_descriptions[port_index].port_width_in_bits = 8;
    port_descriptions[port_index].protocol_name = "generic";
    port_descriptions[port_index].ipxactBusDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactBusDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactBusDef.name = "generic";
    port_descriptions[port_index].ipxactBusDef.version = "1.0"; 
    port_descriptions[port_index].ipxactAbstrDef.vendor = "Mentor.com";
    port_descriptions[port_index].ipxactAbstrDef.library = "Lib_ipxact";
    port_descriptions[port_index].ipxactAbstrDef.name = "generic_tlm20";
    port_descriptions[port_index].ipxactAbstrDef.version = "1.0";
    port_descriptions[port_index].port_must_bind = 1;
    port_descriptions[port_index].params_count = 6 + 10;
    port_descriptions[port_index].clock = generic_clock;
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
    port_descriptions[port_index].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  

  port_descriptions[Sensor].default_read_transaction_name = "READ";
  
  port_descriptions[NetworkMaster].default_read_transaction_name = "READ";
  
  port_descriptions[NetworkSlave].default_read_transaction_name = "READ";
  
  port_descriptions[Sensor].default_write_transaction_name = "WRITE";
  
  port_descriptions[NetworkMaster].default_write_transaction_name = "WRITE";
  
  port_descriptions[NetworkSlave].default_write_transaction_name = "WRITE";
  

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);

  bool isCpu = false;
  
  esl::tlm_sim::UserRunningModel* userRunningModel = Papoulis_CreateUserRunningModel(name(),
                                                                                     0,
                                                                                     this,
                                                                                     simulation,
                                                                                     false,
                                                                                     isCpu);
  setUserRunningModel(userRunningModel, isCpu);
  set_nominal_voltage(nominal_voltage);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("generic_clock", "sc_core::sc_time", sdGetParameterAsConstString("generic_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("mb_debug", "bool", sdGetParameterAsConstString("mb_debug"));
  registerParameter("call_to_default_if", "bool", sdGetParameterAsConstString("call_to_default_if"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("NetworkSlave_pipeline_length", "unsigned int", sdGetParameterAsConstString("NetworkSlave_pipeline_length"));
  registerParameter("SampleIntervalInClocks", "unsigned int", sdGetParameterAsConstString("SampleIntervalInClocks"));
  registerParameter("NumberOfSamplesPerPacket", "unsigned int", sdGetParameterAsConstString("NumberOfSamplesPerPacket"));
  registerParameter("MinRetryDelayInClocks", "unsigned int", sdGetParameterAsConstString("MinRetryDelayInClocks"));
  registerParameter("MaxRetryDelayInClocks", "unsigned int", sdGetParameterAsConstString("MaxRetryDelayInClocks"));
  registerParameter("MaxNumberOfRetrys", "unsigned int", sdGetParameterAsConstString("MaxNumberOfRetrys"));
  registerParameter("AcknowledgeTimeoutInClocks", "unsigned int", sdGetParameterAsConstString("AcknowledgeTimeoutInClocks"));
  registerParameter("MacAddress", "unsigned long long", sdGetParameterAsConstString("MacAddress"));
  registerParameter("MacAddressSystemController", "unsigned long long", sdGetParameterAsConstString("MacAddressSystemController"));
  registerParameter("TotalNumberOfPackets", "unsigned int", sdGetParameterAsConstString("TotalNumberOfPackets"));
  registerParameter("SampleFifoSize", "unsigned int", sdGetParameterAsConstString("SampleFifoSize"));
  set_sync_all(0); 
  set_sync_all(0);
  
  
  
  

  
  

  delay_policy* delay_policy_handle = 0;

  for (unsigned u = 0; u < 1; u++) {
    unsigned port_index = NetworkSlave + u;
    
    std::string str = std::string(port_descriptions[port_index].port_name);
    delay_policy_handle = new delay_policy(userRunningModel,
                                           str.c_str(),
                                           7,
                                           0,
                                           mb::tlm20::SYNC_BEGIN);
    delay_policy_handle->set_power(2);
    m_delay_vector.push_back(delay_policy_handle);
  }

  

  constant_global_power_policy* p = new constant_global_power_policy(userRunningModel);
  
  
  set_nominal_clock(1000000/100); /* in ps */ 
  update_coefficients();
  set_global_power_policy(p);
}

void SensorNodeLevel1_t_base::update_sync_all() {
  set_sync_all(0);
  set_sync_all(0);
}

void SensorNodeLevel1_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;


}

void SensorNodeLevel1_t_base::update_sequential_parameters(esl::sc_sim::sequential_policy* handle) {
  if (m_sequential_vector.size() == 0)
    return;

}

void SensorNodeLevel1_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(7);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(2);
    return;
  }
}

void SensorNodeLevel1_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}

void SensorNodeLevel1_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}

void SensorNodeLevel1_t_base::update_state_power_parameters(esl::sc_sim::state_power_policy* handle) {
  if (m_state_power_vector.size() == 0)
    return;

}

void SensorNodeLevel1_t_base::update_global_power_parameters(esl::sc_sim::constant_global_power_policy* handle) {
  
  
  return;  
}

bool SensorNodeLevel1_t_base::triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans) {
  mb::utl::Segment<uint64_t> transactionRange(trans.get_address(), trans.get_address() + trans.get_data_length());

  return false;
}

bool SensorNodeLevel1_t_base::portHasRegisters(unsigned portIndex) {
  switch (portIndex) {

  }
  return false;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for SensorNodeLevel1.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 17, 2016 01:56:50 AM, (user: kenm)
//*>

#include "SensorNodeLevel1_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "SensorNodeLevel1_pv.h"




// Constructor

SensorNodeLevel1_pvt::SensorNodeLevel1_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    SensorNodeLevel1_pvt_param_defaults(this->name()),
    Sensor("Sensor"),
    NetworkMaster("NetworkMaster"),
    NetworkSlave("NetworkSlave"),
    Sensor_entry("unvisible_Sensor_entry"),
    NetworkMaster_entry("unvisible_NetworkMaster_entry"),
    NetworkSlave_entry("unvisible_NetworkSlave_entry"),
    m_Sensor_nb_connector(*this),
    m_NetworkMaster_nb_connector(*this),
    m_NetworkSlave_nb_connector(*this)
    

{
  // Sensor - not a vector port
  // NetworkMaster - not a vector port
  // NetworkSlave - not a vector port



  m_SensorNodeLevel1_t = SensorNodeLevel1_t_base::create_t("T", 1);
  m_SensorNodeLevel1_pv = new SensorNodeLevel1_pv("PV");
  bind();
}  


SensorNodeLevel1_pvt::SensorNodeLevel1_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time generic_clock_init, double nominal_voltage_init, bool mb_debug_init, bool call_to_default_if_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int NetworkSlave_pipeline_length_init, unsigned int SampleIntervalInClocks_init, unsigned int NumberOfSamplesPerPacket_init, unsigned int MinRetryDelayInClocks_init, unsigned int MaxRetryDelayInClocks_init, unsigned int MaxNumberOfRetrys_init, unsigned int AcknowledgeTimeoutInClocks_init, unsigned long long MacAddress_init, unsigned long long MacAddressSystemController_init, unsigned int TotalNumberOfPackets_init, unsigned int SampleFifoSize_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  SensorNodeLevel1_pvt_param_defaults(this->name(), clock_init, generic_clock_init, nominal_voltage_init, mb_debug_init, call_to_default_if_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, NetworkSlave_pipeline_length_init, SampleIntervalInClocks_init, NumberOfSamplesPerPacket_init, MinRetryDelayInClocks_init, MaxRetryDelayInClocks_init, MaxNumberOfRetrys_init, AcknowledgeTimeoutInClocks_init, MacAddress_init, MacAddressSystemController_init, TotalNumberOfPackets_init, SampleFifoSize_init),
    Sensor("Sensor"),
    NetworkMaster("NetworkMaster"),
    NetworkSlave("NetworkSlave"),
    Sensor_entry("unvisible_Sensor_entry"),
    NetworkMaster_entry("unvisible_NetworkMaster_entry"),
    NetworkSlave_entry("unvisible_NetworkSlave_entry"),
    m_Sensor_nb_connector(*this),
    m_NetworkMaster_nb_connector(*this),
    m_NetworkSlave_nb_connector(*this)
    
{

  // Sensor - not a vector port
  // NetworkMaster - not a vector port
  // NetworkSlave - not a vector port
  


  m_SensorNodeLevel1_t = SensorNodeLevel1_t_base::create_t("T", 1);
  m_SensorNodeLevel1_pv = new SensorNodeLevel1_pv("PV");
  bind();
} 

SensorNodeLevel1_pvt::SensorNodeLevel1_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  SensorNodeLevel1_pvt_param_defaults(this->name(), change_parameters),
    Sensor("Sensor"),
    NetworkMaster("NetworkMaster"),
    NetworkSlave("NetworkSlave"),
    Sensor_entry("unvisible_Sensor_entry"),
    NetworkMaster_entry("unvisible_NetworkMaster_entry"),
    NetworkSlave_entry("unvisible_NetworkSlave_entry"),
    m_Sensor_nb_connector(*this),
    m_NetworkMaster_nb_connector(*this),
    m_NetworkSlave_nb_connector(*this)
    
{

  // Sensor - not a vector port
  // NetworkMaster - not a vector port
  // NetworkSlave - not a vector port
  


  m_SensorNodeLevel1_t = SensorNodeLevel1_t_base::create_t("T", 1);
  m_SensorNodeLevel1_pv = new SensorNodeLevel1_pv("PV");
  bind();
} 

SensorNodeLevel1_pvt::~SensorNodeLevel1_pvt() {
  remove_pending_scenes();
  delete m_SensorNodeLevel1_t; delete m_SensorNodeLevel1_pv;
}




void SensorNodeLevel1_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->Sensor.bind(Sensor_entry);
  getPV()->NetworkMaster.bind(NetworkMaster_entry);
  NetworkSlave_entry.bind(getPV()->NetworkSlave);    

  /* set callbacks on external and entry ports */ 

  NetworkSlave.b_transport_cb.set(&NetworkSlave_entry, &NetworkSlave_entry_type::b_transport);
  NetworkSlave.transport_dbg_cb.set(&NetworkSlave_entry, &NetworkSlave_entry_type::transport_dbg);
  NetworkSlave.get_direct_mem_ptr_cb.set(&NetworkSlave_entry, &NetworkSlave_entry_type::get_direct_mem_ptr);
  
  Sensor_entry.b_transport_cb.set(this, &self_type::b_transport_outside_Sensor);
  Sensor_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_Sensor);
  Sensor_entry.get_direct_mem_ptr_cb.set(&Sensor, &Sensor_type::get_direct_mem_ptr);
  
  NetworkMaster_entry.b_transport_cb.set(this, &self_type::b_transport_outside_NetworkMaster);
  NetworkMaster_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_NetworkMaster);
  NetworkMaster_entry.get_direct_mem_ptr_cb.set(&NetworkMaster, &NetworkMaster_type::get_direct_mem_ptr);
  
  
  /* connect t non blocking callbacks */

  Sensor.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_Sensor);
  getT()->set_port_cb(0, &m_Sensor_nb_connector);
  
  NetworkMaster.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_NetworkMaster);
  getT()->set_port_cb(1, &m_NetworkMaster_nb_connector);
  
  NetworkSlave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_NetworkSlave);
  getT()->set_port_cb(2, &m_NetworkSlave_nb_connector);
  
  NetworkSlave_entry.invalidate_direct_mem_ptr_cb.set(&NetworkSlave, &NetworkSlave_type::invalidate_direct_mem_ptr);

  Sensor.invalidate_direct_mem_ptr_cb.set(&Sensor_entry, &Sensor_entry_type::invalidate_direct_mem_ptr);
  
  NetworkMaster.invalidate_direct_mem_ptr_cb.set(&NetworkMaster_entry, &NetworkMaster_entry_type::invalidate_direct_mem_ptr);
  
  /* check mb_event policies */
  m_SensorNodeLevel1_t->check_mb_events();
}



void SensorNodeLevel1_pvt::b_transport_outside_Sensor(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  Sensor.b_transport(p, t);
  
} 

unsigned int SensorNodeLevel1_pvt::transport_dbg_outside_Sensor(tlm::tlm_generic_payload& p)
{
  
  return Sensor.transport_dbg(p);
  
}

void SensorNodeLevel1_pvt::b_transport_outside_NetworkMaster(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  NetworkMaster.b_transport(p, t);
  
} 

unsigned int SensorNodeLevel1_pvt::transport_dbg_outside_NetworkMaster(tlm::tlm_generic_payload& p)
{
  
  return NetworkMaster.transport_dbg(p);
  
}

