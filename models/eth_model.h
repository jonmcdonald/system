
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The eth_pv will be derived from this class.
//*
//* Model Builder version: 4.2.0
//* Generated on: Aug. 12, 2016 10:08:49 AM, (user: jon)
//*>



#pragma once

#include "model_builder.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4200 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.2.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif




#include "generic_protocol.h"

using namespace ::tlm;

class eth_pv_base;
class eth_pv_base_mb_compatibility : public mb::mb_module {
  friend class eth_pv_base;
 public:
  typedef unsigned int mb_address_type;
 protected:
  eth_pv_base_mb_compatibility(sc_core::sc_module_name& module_name)
    : mb::mb_module(module_name) {}

  ////////////////////////////////////////
  // functions for target port: d0
  ////////////////////////////////////////
  protected:
   virtual bool d0_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   } 
   virtual bool d0_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   } 
   virtual unsigned d0_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   } 
   virtual unsigned d0_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool d0_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   }
  ////////////////////////////////////////
  // functions for target port: d1
  ////////////////////////////////////////
  protected:
   virtual bool d1_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   } 
   virtual bool d1_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   } 
   virtual unsigned d1_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   } 
   virtual unsigned d1_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool d1_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   }
  ////////////////////////////////////////
  // functions for target port: d2
  ////////////////////////////////////////
  protected:
   virtual bool d2_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   } 
   virtual bool d2_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   } 
   virtual unsigned d2_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   } 
   virtual unsigned d2_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool d2_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   }
  ////////////////////////////////////////
  // functions for target port: d3
  ////////////////////////////////////////
  protected:
   virtual bool d3_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   } 
   virtual bool d3_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   } 
   virtual unsigned d3_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   } 
   virtual unsigned d3_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool d3_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   }
  ////////////////////////////////////////
  // functions for target port: d4
  ////////////////////////////////////////
  protected:
   virtual bool d4_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   } 
   virtual bool d4_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   } 
   virtual unsigned d4_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   } 
   virtual unsigned d4_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool d4_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   }
  ////////////////////////////////////////
  // functions for target port: d5
  ////////////////////////////////////////
  protected:
   virtual bool d5_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   } 
   virtual bool d5_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   } 
   virtual unsigned d5_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   } 
   virtual unsigned d5_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool d5_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   } 
};

class eth_pv_base_parameters {
 public :
  eth_pv_base_parameters(sc_object* object);
  void print_parameters();

 protected:
  sc_object* m_object;

  sc_core::sc_time clock;
  sc_core::sc_time generic_clock;
  double nominal_voltage;
  bool verbose_parameters;
  bool dmi_enabled;
  const char* warning_level;
  const char* layers;
  const char* slave_sets;
  unsigned int write_broadcast;
  unsigned long long r0_base_address;
  unsigned long long r0_size;
  unsigned int r0_subtract_base_address;
  unsigned int r0_secure;
  const char* r0_additional_ranges;
  unsigned int r0_latency;
  unsigned int d0_priority;
  const char* d0_vmap;
  unsigned long long r1_base_address;
  unsigned long long r1_size;
  unsigned int r1_subtract_base_address;
  unsigned int r1_secure;
  const char* r1_additional_ranges;
  unsigned int r1_latency;
  unsigned int d1_priority;
  const char* d1_vmap;
  unsigned long long r2_base_address;
  unsigned long long r2_size;
  unsigned int r2_subtract_base_address;
  unsigned int r2_secure;
  const char* r2_additional_ranges;
  unsigned int r2_latency;
  unsigned int d2_priority;
  const char* d2_vmap;
  unsigned long long r3_base_address;
  unsigned long long r3_size;
  unsigned int r3_subtract_base_address;
  unsigned int r3_secure;
  const char* r3_additional_ranges;
  unsigned int r3_latency;
  unsigned int d3_priority;
  const char* d3_vmap;
  unsigned long long r4_base_address;
  unsigned long long r4_size;
  unsigned int r4_subtract_base_address;
  unsigned int r4_secure;
  const char* r4_additional_ranges;
  unsigned int r4_latency;
  unsigned int d4_priority;
  const char* d4_vmap;
  unsigned long long r5_base_address;
  unsigned long long r5_size;
  unsigned int r5_subtract_base_address;
  unsigned int r5_secure;
  const char* r5_additional_ranges;
  unsigned int r5_latency;
  unsigned int d5_priority;
  const char* d5_vmap;
};

class eth_pv_base : public eth_pv_base_mb_compatibility,
                           public eth_pv_base_parameters
{
 private:
  typedef eth_pv_base_mb_compatibility mb_compatibility_class;
  typedef eth_pv_base_mb_compatibility BASE_TYPE;
 public:
  typedef esl::tlm_types::Address mb_address_type;
 public:
  typedef eth_pv_base self;
  SC_HAS_PROCESS(eth_pv_base);
  eth_pv_base(sc_core::sc_module_name& module_name);
  virtual void reset_registers();
  virtual void reset_model();
  enum port_enum {r0_idx = 0,d0_idx = 1,r1_idx = 2,d1_idx = 3,r2_idx = 4,d2_idx = 5,r3_idx = 6,d3_idx = 7,r4_idx = 8,d4_idx = 9,r5_idx = 10,d5_idx = 11 };
  
 private:

  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_r0_bw_process;
  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_r1_bw_process;
  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_r2_bw_process;
  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_r3_bw_process;
  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_r4_bw_process;
  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_r5_bw_process;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_d0_fw_process;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_d1_fw_process;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_d2_fw_process;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_d3_fw_process;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_d4_fw_process;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_d5_fw_process;

 protected:

  virtual void d0_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (trans.get_byte_enable_ptr() && trans.get_byte_enable_length()) {
      std::stringstream str;
      str << std::showbase << std::hex;
      if (trans.is_write())
        str << "writing to address " << trans.get_address() << " : byte enable pointer defined but not used ";
      else
        str << "reading from address " << trans.get_address() << " : byte enable pointer defined but not used ";
      mb::sysc::complain(str.str().c_str(), this->name());
    }
    payload_for_token = &trans;
    
    if (trans.is_write()) {
      status = d0_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d0_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    payload_for_token = 0;

    tlm::tlm_response_status trans_status = trans.get_response_status();
    if (trans_status == tlm::TLM_INCOMPLETE_RESPONSE ||
        trans_status == tlm::TLM_OK_RESPONSE)
      trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned d0_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    unsigned status = 0;
    if (trans.is_write()) {
      status = d0_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d0_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } 

    return status;
  }

  virtual bool d0_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = d0_get_direct_memory_ptr(trans.get_address(), dmiData);
    if (ret_value) {
      get_dmi_delay_cb(trans, dmiData, d0_idx);
    }
    payload_on_stack = 0;
    return ret_value;
  }
  virtual void d1_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (trans.get_byte_enable_ptr() && trans.get_byte_enable_length()) {
      std::stringstream str;
      str << std::showbase << std::hex;
      if (trans.is_write())
        str << "writing to address " << trans.get_address() << " : byte enable pointer defined but not used ";
      else
        str << "reading from address " << trans.get_address() << " : byte enable pointer defined but not used ";
      mb::sysc::complain(str.str().c_str(), this->name());
    }
    payload_for_token = &trans;
    
    if (trans.is_write()) {
      status = d1_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d1_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    payload_for_token = 0;

    tlm::tlm_response_status trans_status = trans.get_response_status();
    if (trans_status == tlm::TLM_INCOMPLETE_RESPONSE ||
        trans_status == tlm::TLM_OK_RESPONSE)
      trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned d1_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    unsigned status = 0;
    if (trans.is_write()) {
      status = d1_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d1_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } 

    return status;
  }

  virtual bool d1_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = d1_get_direct_memory_ptr(trans.get_address(), dmiData);
    if (ret_value) {
      get_dmi_delay_cb(trans, dmiData, d1_idx);
    }
    payload_on_stack = 0;
    return ret_value;
  }
  virtual void d2_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (trans.get_byte_enable_ptr() && trans.get_byte_enable_length()) {
      std::stringstream str;
      str << std::showbase << std::hex;
      if (trans.is_write())
        str << "writing to address " << trans.get_address() << " : byte enable pointer defined but not used ";
      else
        str << "reading from address " << trans.get_address() << " : byte enable pointer defined but not used ";
      mb::sysc::complain(str.str().c_str(), this->name());
    }
    payload_for_token = &trans;
    
    if (trans.is_write()) {
      status = d2_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d2_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    payload_for_token = 0;

    tlm::tlm_response_status trans_status = trans.get_response_status();
    if (trans_status == tlm::TLM_INCOMPLETE_RESPONSE ||
        trans_status == tlm::TLM_OK_RESPONSE)
      trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned d2_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    unsigned status = 0;
    if (trans.is_write()) {
      status = d2_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d2_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } 

    return status;
  }

  virtual bool d2_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = d2_get_direct_memory_ptr(trans.get_address(), dmiData);
    if (ret_value) {
      get_dmi_delay_cb(trans, dmiData, d2_idx);
    }
    payload_on_stack = 0;
    return ret_value;
  }
  virtual void d3_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (trans.get_byte_enable_ptr() && trans.get_byte_enable_length()) {
      std::stringstream str;
      str << std::showbase << std::hex;
      if (trans.is_write())
        str << "writing to address " << trans.get_address() << " : byte enable pointer defined but not used ";
      else
        str << "reading from address " << trans.get_address() << " : byte enable pointer defined but not used ";
      mb::sysc::complain(str.str().c_str(), this->name());
    }
    payload_for_token = &trans;
    
    if (trans.is_write()) {
      status = d3_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d3_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    payload_for_token = 0;

    tlm::tlm_response_status trans_status = trans.get_response_status();
    if (trans_status == tlm::TLM_INCOMPLETE_RESPONSE ||
        trans_status == tlm::TLM_OK_RESPONSE)
      trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned d3_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    unsigned status = 0;
    if (trans.is_write()) {
      status = d3_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d3_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } 

    return status;
  }

  virtual bool d3_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = d3_get_direct_memory_ptr(trans.get_address(), dmiData);
    if (ret_value) {
      get_dmi_delay_cb(trans, dmiData, d3_idx);
    }
    payload_on_stack = 0;
    return ret_value;
  }
  virtual void d4_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (trans.get_byte_enable_ptr() && trans.get_byte_enable_length()) {
      std::stringstream str;
      str << std::showbase << std::hex;
      if (trans.is_write())
        str << "writing to address " << trans.get_address() << " : byte enable pointer defined but not used ";
      else
        str << "reading from address " << trans.get_address() << " : byte enable pointer defined but not used ";
      mb::sysc::complain(str.str().c_str(), this->name());
    }
    payload_for_token = &trans;
    
    if (trans.is_write()) {
      status = d4_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d4_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    payload_for_token = 0;

    tlm::tlm_response_status trans_status = trans.get_response_status();
    if (trans_status == tlm::TLM_INCOMPLETE_RESPONSE ||
        trans_status == tlm::TLM_OK_RESPONSE)
      trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned d4_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    unsigned status = 0;
    if (trans.is_write()) {
      status = d4_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d4_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } 

    return status;
  }

  virtual bool d4_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = d4_get_direct_memory_ptr(trans.get_address(), dmiData);
    if (ret_value) {
      get_dmi_delay_cb(trans, dmiData, d4_idx);
    }
    payload_on_stack = 0;
    return ret_value;
  }
  virtual void d5_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (trans.get_byte_enable_ptr() && trans.get_byte_enable_length()) {
      std::stringstream str;
      str << std::showbase << std::hex;
      if (trans.is_write())
        str << "writing to address " << trans.get_address() << " : byte enable pointer defined but not used ";
      else
        str << "reading from address " << trans.get_address() << " : byte enable pointer defined but not used ";
      mb::sysc::complain(str.str().c_str(), this->name());
    }
    payload_for_token = &trans;
    
    if (trans.is_write()) {
      status = d5_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d5_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    payload_for_token = 0;

    tlm::tlm_response_status trans_status = trans.get_response_status();
    if (trans_status == tlm::TLM_INCOMPLETE_RESPONSE ||
        trans_status == tlm::TLM_OK_RESPONSE)
      trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned d5_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    unsigned status = 0;
    if (trans.is_write()) {
      status = d5_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = d5_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } 

    return status;
  }

  virtual bool d5_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = d5_get_direct_memory_ptr(trans.get_address(), dmiData);
    if (ret_value) {
      get_dmi_delay_cb(trans, dmiData, d5_idx);
    }
    payload_on_stack = 0;
    return ret_value;
  }

  virtual void get_dmi_delay_cb(tlm::tlm_generic_payload& trans, tlm::tlm_dmi& dmiData, unsigned port_index) {
    sc_time t = sc_core::SC_ZERO_TIME;
    
    getPVTBaseModel()->get_write_delay_for_dmi(port_index, trans, t);
    dmiData.set_write_latency(t);
    t = sc_core::SC_ZERO_TIME;
    getPVTBaseModel()->get_read_delay_for_dmi(port_index, trans, t);
    dmiData.set_read_latency(t);
    
  }

  virtual void invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void r0_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void r1_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void r2_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void r3_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void r4_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void r5_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }

  

  



  

  
  

 public:

  ////////////////////////////////////////
  // functions for initiator port: r0
  ////////////////////////////////////////
  bool r0_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    r0->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool r0_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r0_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r0_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r0_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r0_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r0_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r0_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r0_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool r0_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r0_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r0_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r0_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r0_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r0_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r0_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r0_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool r0_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r0_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r0_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r0_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r0_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r0_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r0_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r0_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool r0_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r0_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r0_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r0_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r0_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r0_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r0_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r0_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 

  ////////////////////////////////////////
  // functions for initiator port: r1
  ////////////////////////////////////////
  bool r1_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    r1->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool r1_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r1_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r1_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r1_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r1_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r1_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r1_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r1_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool r1_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r1_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r1_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r1_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r1_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r1_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r1_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r1_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool r1_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r1_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r1_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r1_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r1_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r1_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r1_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r1_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool r1_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r1_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r1_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r1_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r1_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r1_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r1_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r1_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 

  ////////////////////////////////////////
  // functions for initiator port: r2
  ////////////////////////////////////////
  bool r2_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    r2->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool r2_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r2_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r2_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r2_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r2_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r2_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r2_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r2_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool r2_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r2_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r2_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r2_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r2_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r2_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r2_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r2_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool r2_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r2_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r2_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r2_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r2_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r2_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r2_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r2_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool r2_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r2_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r2_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r2_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r2_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r2_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r2_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r2_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r2[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 

  ////////////////////////////////////////
  // functions for initiator port: r3
  ////////////////////////////////////////
  bool r3_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    r3->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool r3_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r3_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r3_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r3_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r3_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r3_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r3_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r3_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool r3_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r3_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r3_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r3_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r3_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r3_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r3_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r3_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool r3_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r3_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r3_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r3_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r3_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r3_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r3_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r3_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool r3_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r3_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r3_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r3_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r3_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r3_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r3_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r3_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r3[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 

  ////////////////////////////////////////
  // functions for initiator port: r4
  ////////////////////////////////////////
  bool r4_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    r4->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool r4_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r4_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r4_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r4_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r4_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r4_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r4_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r4_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool r4_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r4_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r4_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r4_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r4_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r4_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r4_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r4_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool r4_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r4_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r4_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r4_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r4_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r4_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r4_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r4_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool r4_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r4_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r4_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r4_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r4_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r4_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r4_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r4_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r4[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 

  ////////////////////////////////////////
  // functions for initiator port: r5
  ////////////////////////////////////////
  bool r5_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    r5->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool r5_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r5_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r5_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r5_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r5_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r5_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r5_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool r5_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool r5_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r5_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r5_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r5_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r5_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r5_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r5_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool r5_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool r5_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r5_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r5_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r5_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r5_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r5_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r5_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool r5_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool r5_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r5_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r5_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r5_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r5_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r5_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r5_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool r5_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*r5[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 



  ///////////////////////////////////////
  // dbg functions for port: r0
  /////////////////////////////////////// 
  
  
  unsigned r0_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r0_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r0_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r0_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r0_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r0_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r0_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r0_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r0_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r0_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 

  ///////////////////////////////////////
  // dbg functions for port: r1
  /////////////////////////////////////// 
  
  
  unsigned r1_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r1_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r1_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r1_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r1_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r1_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r1_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r1_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r1_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r1_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 

  ///////////////////////////////////////
  // dbg functions for port: r2
  /////////////////////////////////////// 
  
  
  unsigned r2_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r2_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r2_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r2_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r2_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r2_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r2_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r2_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r2_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r2_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r2[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 

  ///////////////////////////////////////
  // dbg functions for port: r3
  /////////////////////////////////////// 
  
  
  unsigned r3_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r3_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r3_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r3_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r3_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r3_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r3_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r3_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r3_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r3_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r3[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 

  ///////////////////////////////////////
  // dbg functions for port: r4
  /////////////////////////////////////// 
  
  
  unsigned r4_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r4_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r4_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r4_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r4_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r4_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r4_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r4_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r4_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r4_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r4[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 

  ///////////////////////////////////////
  // dbg functions for port: r5
  /////////////////////////////////////// 
  
  
  unsigned r5_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r5_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r5_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r5_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r5_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r5_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r5_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned r5_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned r5_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned r5_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*r5[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 


  tlm::tlm_generic_payload* payload_on_stack;
  tlm::tlm_generic_payload* payload_for_token;

  ////////////////////////////////////////
  // request DMI for port: r0
  ////////////////////////////////////////
  bool r0_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = r0->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool r0_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = r0->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }
  ////////////////////////////////////////
  // request DMI for port: r1
  ////////////////////////////////////////
  bool r1_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = r1->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool r1_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = r1->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }
  ////////////////////////////////////////
  // request DMI for port: r2
  ////////////////////////////////////////
  bool r2_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = r2->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool r2_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = r2->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }
  ////////////////////////////////////////
  // request DMI for port: r3
  ////////////////////////////////////////
  bool r3_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = r3->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool r3_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = r3->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }
  ////////////////////////////////////////
  // request DMI for port: r4
  ////////////////////////////////////////
  bool r4_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = r4->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool r4_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = r4->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }
  ////////////////////////////////////////
  // request DMI for port: r5
  ////////////////////////////////////////
  bool r5_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = r5->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool r5_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = r5->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }


  ////////////////////////////////////////
  // functions for target port: d0
  ////////////////////////////////////////
  protected:
  virtual bool d0_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
    mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d0_callback_read(mb_compatibility_class::mb_address_type(local_address),
                                                        data,
                                                        size);
   }
   virtual bool d0_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d0_callback_write(mb_compatibility_class::mb_address_type(local_address),
                                                         data,
                                                         size);
   }

   virtual unsigned d0_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->d0_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned d0_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->d0_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool d0_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->d0_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   }
  ////////////////////////////////////////
  // functions for target port: d1
  ////////////////////////////////////////
  protected:
  virtual bool d1_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
    mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d1_callback_read(mb_compatibility_class::mb_address_type(local_address),
                                                        data,
                                                        size);
   }
   virtual bool d1_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d1_callback_write(mb_compatibility_class::mb_address_type(local_address),
                                                         data,
                                                         size);
   }

   virtual unsigned d1_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->d1_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned d1_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->d1_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool d1_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->d1_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   }
  ////////////////////////////////////////
  // functions for target port: d2
  ////////////////////////////////////////
  protected:
  virtual bool d2_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
    mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d2_callback_read(mb_compatibility_class::mb_address_type(local_address),
                                                        data,
                                                        size);
   }
   virtual bool d2_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d2_callback_write(mb_compatibility_class::mb_address_type(local_address),
                                                         data,
                                                         size);
   }

   virtual unsigned d2_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->d2_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned d2_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->d2_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool d2_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->d2_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   }
  ////////////////////////////////////////
  // functions for target port: d3
  ////////////////////////////////////////
  protected:
  virtual bool d3_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
    mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d3_callback_read(mb_compatibility_class::mb_address_type(local_address),
                                                        data,
                                                        size);
   }
   virtual bool d3_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d3_callback_write(mb_compatibility_class::mb_address_type(local_address),
                                                         data,
                                                         size);
   }

   virtual unsigned d3_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->d3_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned d3_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->d3_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool d3_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->d3_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   }
  ////////////////////////////////////////
  // functions for target port: d4
  ////////////////////////////////////////
  protected:
  virtual bool d4_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
    mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d4_callback_read(mb_compatibility_class::mb_address_type(local_address),
                                                        data,
                                                        size);
   }
   virtual bool d4_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d4_callback_write(mb_compatibility_class::mb_address_type(local_address),
                                                         data,
                                                         size);
   }

   virtual unsigned d4_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->d4_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned d4_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->d4_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool d4_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->d4_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   }
  ////////////////////////////////////////
  // functions for target port: d5
  ////////////////////////////////////////
  protected:
  virtual bool d5_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
    mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d5_callback_read(mb_compatibility_class::mb_address_type(local_address),
                                                        data,
                                                        size);
   }
   virtual bool d5_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_address_type local_address = address;
     mb_compatibility_class *This = this;
     return This->d5_callback_write(mb_compatibility_class::mb_address_type(local_address),
                                                         data,
                                                         size);
   }

   virtual unsigned d5_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->d5_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned d5_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->d5_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool d5_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->d5_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   } 

   
  
  
 

 public:
  typedef tlm::tlm_base_protocol_types r0_protocol_types;
  typedef tlm::tlm_base_protocol_types r1_protocol_types;
  typedef tlm::tlm_base_protocol_types r2_protocol_types;
  typedef tlm::tlm_base_protocol_types r3_protocol_types;
  typedef tlm::tlm_base_protocol_types r4_protocol_types;
  typedef tlm::tlm_base_protocol_types r5_protocol_types;
  typedef tlm::tlm_base_protocol_types d0_protocol_types;
  typedef tlm::tlm_base_protocol_types d1_protocol_types;
  typedef tlm::tlm_base_protocol_types d2_protocol_types;
  typedef tlm::tlm_base_protocol_types d3_protocol_types;
  typedef tlm::tlm_base_protocol_types d4_protocol_types;
  typedef tlm::tlm_base_protocol_types d5_protocol_types;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type r0_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type r1_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type r2_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type r3_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type r4_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type r5_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type d0_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type d1_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type d2_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type d3_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type d4_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type d5_payload_type;

 public:
  // port declarations 

  tlm::tlm_initiator_socket <32, tlm::tlm_base_protocol_types> r0;
  tlm::tlm_initiator_socket <32, tlm::tlm_base_protocol_types> r1;
  tlm::tlm_initiator_socket <32, tlm::tlm_base_protocol_types> r2;
  tlm::tlm_initiator_socket <32, tlm::tlm_base_protocol_types> r3;
  tlm::tlm_initiator_socket <32, tlm::tlm_base_protocol_types> r4;
  tlm::tlm_initiator_socket <32, tlm::tlm_base_protocol_types> r5;
  tlm::tlm_target_socket <32, tlm::tlm_base_protocol_types>  d0;
  tlm::tlm_target_socket <32, tlm::tlm_base_protocol_types>  d1;
  tlm::tlm_target_socket <32, tlm::tlm_base_protocol_types>  d2;
  tlm::tlm_target_socket <32, tlm::tlm_base_protocol_types>  d3;
  tlm::tlm_target_socket <32, tlm::tlm_base_protocol_types>  d4;
  tlm::tlm_target_socket <32, tlm::tlm_base_protocol_types>  d5;  

    
 public:
  void send_b_transport(unsigned port_index, tlm::tlm_generic_payload& trans, sc_core::sc_time& t) {
    if (port_index > get_port_count() || !is_master(port_index))
      return;

    if (port_index >= r0_idx && port_index <= r0_idx)
      return r0->b_transport(trans, t);
    if (port_index >= r1_idx && port_index <= r1_idx)
      return r1->b_transport(trans, t);
    if (port_index >= r2_idx && port_index <= r2_idx)
      return r2->b_transport(trans, t);
    if (port_index >= r3_idx && port_index <= r3_idx)
      return r3->b_transport(trans, t);
    if (port_index >= r4_idx && port_index <= r4_idx)
      return r4->b_transport(trans, t);
    if (port_index >= r5_idx && port_index <= r5_idx)
      return r5->b_transport(trans, t);
    return;
    
  }

  unsigned send_transport_dbg(unsigned port_index, tlm::tlm_generic_payload& trans) {
    if (port_index > get_port_count() || !is_master(port_index))
      return 0;

    if (port_index >= r0_idx && port_index <= r0_idx)
      return r0->transport_dbg(trans);
    if (port_index >= r1_idx && port_index <= r1_idx)
      return r1->transport_dbg(trans);
    if (port_index >= r2_idx && port_index <= r2_idx)
      return r2->transport_dbg(trans);
    if (port_index >= r3_idx && port_index <= r3_idx)
      return r3->transport_dbg(trans);
    if (port_index >= r4_idx && port_index <= r4_idx)
      return r4->transport_dbg(trans);
    if (port_index >= r5_idx && port_index <= r5_idx)
      return r5->transport_dbg(trans);
    
    return 0;
  }
  
  

 public:
  mb::mb_token_ptr get_current_token() {
    mb::mb_token_ptr token_ptr = mb_module::get_current_token();
    if (token_ptr)
      return token_ptr;
    if (payload_for_token) {
      mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*payload_for_token);
      if (extension) {
        mb_module::set_current_token(extension->getToken());
        return extension->getToken();
      }
    }
    return 0;
  }
  

 protected:
};



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/


#pragma once

#include "eth_model.h"
#include "model_builder.h"
#include <queue>


class eth_base1_pv : public eth_pv_base,
         public mb::sysc::ParameterListener {
public:
  SC_HAS_PROCESS(eth_base1_pv);
  
  eth_base1_pv(sc_module_name module_name); 

  virtual ~eth_base1_pv();

 public:
  tlm::tlm_target_socket<32, tlm::tlm_base_protocol_types,
    1,
    sc_core::SC_ZERO_OR_MORE_BOUND> dbg_port;
  tlm::tlm_target_socket<32, tlm::tlm_base_protocol_types,
    1,
                         sc_core::SC_ZERO_OR_MORE_BOUND>& get_dbg_port() {
    return dbg_port;
  }
private:
  PapoulisBusBaseModel *m_model;
  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_dbg_port_fw_process;
public:
  virtual void d0_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t);
  virtual unsigned d0_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans);
  virtual bool d0_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData);
  virtual void d1_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t);
  virtual unsigned d1_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans);
  virtual bool d1_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData);
  virtual void d2_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t);
  virtual unsigned d2_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans);
  virtual bool d2_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData);
  virtual void d3_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t);
  virtual unsigned d3_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans);
  virtual bool d3_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData);
  virtual void d4_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t);
  virtual unsigned d4_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans);
  virtual bool d4_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData);
  virtual void d5_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t);
  virtual unsigned d5_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans);
  virtual bool d5_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData);
  void dbg_port_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t);
  unsigned dbg_port_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans); 
  bool dbg_port_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData);

 public: 
  virtual void parameter_changed(const std::string& parameter,
                                 const std::string& old_value,
                                 const std::string& new_value);
  virtual void invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range);
  virtual void r0_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range);
  virtual void r1_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range);
  virtual void r2_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range);
  virtual void r3_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range);
  virtual void r4_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range);
  virtual void r5_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range);

  void invalidate_direct_mem_ptr(unsigned target_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range);

  void set_secure_payload(esl::sc_sim::secure_payload* inst) {
    decoder->setSecurePayload(inst);
  }
protected:
  unsigned m_port_count;
  unsigned m_layers_count;
  bool     m_is_multi_channel;
  esl::sc_sim::BusScheduler *m_bus_scheduler;
  bool m_apply_policies;
  bool m_in_loop;

  tlm::tlm_fw_transport_if<tlm::tlm_base_protocol_types>* get_fw_transport_if(unsigned port_index) {
    switch (port_index) {
    case (0):
      return r0[0];
    case (2):
      return r1[0];
    case (4):
      return r2[0];
    case (6):
      return r3[0];
    case (8):
      return r4[0];
    case (10):
      return r5[0];
    default:
      std::cerr << "Bad port index requested in get_fw_transport_if: " << port_index << std::endl;
      return 0;
    }
  }

  tlm::tlm_bw_transport_if<tlm::tlm_base_protocol_types>* get_bw_transport_if(unsigned port_index) {
    switch (port_index) {
    case (1):
      return d0[0];
    case (3):
      return d1[0];
    case (5):
      return d2[0];
    case (7):
      return d3[0];
    case (9):
      return d4[0];
    case (11):
      return d5[0];
    default:
      std::cerr << "Bad port index requested in get_fw_transport_if: " << port_index << std::endl;
      return 0;
    }
  }

private:
  template <class Payload>
    unsigned routePayload(Payload& trans, unsigned targetPortIndex, bool isDebug, sc_core::sc_time& t) {    
    bool isNotDebugPort = (targetPortIndex != (unsigned) (-1));
    tlm::tlm_command command = trans.get_command();
    bool read_or_write_command = (command == tlm::TLM_READ_COMMAND)||(command == tlm::TLM_WRITE_COMMAND);
    
    sc_core::sc_time waiting_time(0, SC_MS) ;
    sc_core::sc_time returned_time(0, SC_PS);
    sc_dt::uint64 virtualAddress = trans.get_address();
    
    esl::sc_sim::PVTBaseModel* owner = getPVTBaseModel();

     bool isSchedulerOp = ((m_apply_policies)&&(!isDebug)&&(read_or_write_command)&&(mb::tlm20::is_LT_mode()));
     int layer = m_model->get_arbiter()->get_slave_layer(targetPortIndex);
     layer = (layer>0)?layer:0;
     if (isSchedulerOp){
       if (t > sc_core::SC_ZERO_TIME)
         {
           sc_core::wait(t);
           t = sc_core::SC_ZERO_TIME;
         }
     }
    sc_core::sc_time initial_time = t;
    if (isNotDebugPort)
      virtualAddress = decoder->getVirtualAddress(targetPortIndex, trans.get_address());
    unsigned portSize = 32;
    if (isNotDebugPort)
      portSize = getPortSize(targetPortIndex);
    const char* portName = isNotDebugPort ? get_port_name(targetPortIndex) : "dbg_port";
    std::vector<long> slavePortIndexArray;
    bool saved_isDebug = isDebug;
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND) {
      isDebug = true;
    }
    esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE)
        decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, portSize, name(), portName, targetPortIndex, isDebug);
      else
        decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, portSize, name(), portName, targetPortIndex, isDebug);
    } else
      decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, portSize, name(), portName, isDebug);
    if (slavePortIndexArray.size() == 0) {
      trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
      return 0;
    }

    unsigned status = 1;
    unsigned slavePortsSize = slavePortIndexArray.size();
    bool broadcasting = false;
    if (slavePortsSize > 1 && write_broadcast)
      broadcasting = true;
    returned_time = t;
    
    for (unsigned u = 0; u < slavePortsSize; u++) {
      if (broadcasting) {
        t = initial_time;
      }
      long slavePortIndex = slavePortIndexArray[u];
      // check secure
      if (secure_inst) {
        if (secure_inst->get_security_value(trans) ==
            esl::sc_sim::secure_payload::NON_SECURE &&
            decoder->getSecure(slavePortIndex, targetPortIndex)) {
          trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
          std::stringstream str;
          str << "attempt to reach a secured device from an unsecured transaction "
              << ": address " << std::dec << trans.get_address()
              << "(0x" << std::hex << trans.get_address() << ")";
          mb::sysc::issue_warning(str.str().c_str(), this->name());
          return 0;
        }
      }
      trans.set_response_status(TLM_OK_RESPONSE);
      
      sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
      trans.set_address(baseAddress);
      isDebug = saved_isDebug;
      if (isDebug) {
        unsigned size = get_fw_transport_if(slavePortIndex)->transport_dbg(trans);
        return size;
      } else {
        
        ::papoulis::BusMonitor* busMonitor = 0;
        if (getSystemCBaseModel())
          busMonitor = getSystemCBaseModel()->getBusMonitor();
        if (busMonitor)
          busMonitor->b_transport_tracer_prehook(papoulis::BusMonitor::SlaveSide, targetPortIndex, slavePortIndex, trans, t);                          
        if (!isNotDebugPort)
          disable_T();
        if (busMonitor)
          busMonitor->b_transport_tracer_prehook(papoulis::BusMonitor::MasterSide, targetPortIndex, slavePortIndex, trans, t); 

        if (isSchedulerOp) {
          m_bus_scheduler->update_layer(layer, slavePortIndex, command);
          m_bus_scheduler->register_request(targetPortIndex, layer, command);
          m_bus_scheduler->wait_for_event(targetPortIndex, layer, command, waiting_time);
          if (waiting_time > sc_core::SC_ZERO_TIME)
            sc_core::wait(waiting_time);
          unsigned latency = Papoulis_UserRunningModel_GetBusLatency(owner->getSystemCBaseModel()->getUserRunningModel(),
                                                                     papoulis::getSimulationTime(),
                                                                     targetPortIndex,
                                                                     slavePortIndex,
                                                                     trans.get_data_length(),
                                                                     trans.get_address(),
                                                                     0,
                                                                     0,
                                                                     trans.is_write());
          if (latency > 0)
            wait(latency * clock);
        }
        
        get_fw_transport_if(slavePortIndex)->b_transport(trans, t);

        if (busMonitor)
          busMonitor->b_transport_tracer_posthook(papoulis::BusMonitor::MasterSide, targetPortIndex, slavePortIndex, trans, t); 
        if (!isNotDebugPort)
          enable_T();
        if (busMonitor)
          busMonitor->b_transport_tracer_posthook(papoulis::BusMonitor::SlaveSide, targetPortIndex, slavePortIndex, trans, t);
        if (!trans.is_response_ok())
          status = 0;
      }

      if (t > returned_time)
        returned_time = t;
      if (isSchedulerOp) {
        if (broadcasting)
          m_bus_scheduler->notify_next_queue_task(layer, command, initial_time, slavePortIndex);
        else
          m_bus_scheduler->notify_next_queue_task(layer, command, t, slavePortIndex);
      }
      
      // dont broadcast for read
      if (trans.get_command() == tlm::TLM_READ_COMMAND)
        break;
    }
    t = returned_time;
    return status;
  }

  protected:
   unsigned getPortSize(unsigned portIndex) {
     switch(portIndex) {
     case 0 : {
       return 32 >> 3;
     }
     case 2 : {
       return 32 >> 3;
     }
     case 4 : {
       return 32 >> 3;
     }
     case 6 : {
       return 32 >> 3;
     }
     case 8 : {
       return 32 >> 3;
     }
     case 10 : {
       return 32 >> 3;
     }
     case 1 : {
       return 32 >> 3;
     }
     case 3 : {
       return 32 >> 3;
     }
     case 5 : {
       return 32 >> 3;
     }
     case 7 : {
       return 32 >> 3;
     }
     case 9 : {
       return 32 >> 3;
     }
     case 11 : {
       return 32 >> 3;
     }
     default:
       assert(0);
     }
     return sizeof(unsigned int);
   }

 protected:
  esl::sc_sim::user_model::Decoder* decoder;
  
  struct TargetPlusOffset {
    TargetPlusOffset(sc_dt::uint64 address, unsigned target_index, signed long long offset) :
      m_address(address), m_target_index(target_index), m_offset(offset) {}
    sc_dt::uint64 m_address;
    unsigned m_target_index;
    signed long long m_offset;
  };
  std::vector<std::deque<TargetPlusOffset> >  m_dmi_request_array;
  void clip_the_range(sc_dt::uint64 address,
                      sc_dt::uint64 &dmiStartAddress,
                      sc_dt::uint64 &dmiEndAddress,
                      unsigned char* &dmiPtr,
                      long slavePortIndex,
                      signed long long offset);
};




/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The eth_t will be derived from this class.
//*
//* Model Builder version: 4.2.0
//* Generated on: Aug. 12, 2016 10:08:50 AM, (user: jon)
//*>


#pragma once

#include "model_builder.h"
#include "generic_protocol.h"

class eth_t_base: public papoulis::PapoulisBusBaseModel {
public:
  static eth_t_base* create_t(const char* name, long simulation, 
                                        esl::sc_sim::user_model::Arbiter* arbiter = 0);
public:
  eth_t_base(sc_core::sc_module_name& module_name, long simulation,
                       esl::sc_sim::user_model::Arbiter* arbiter = 0);

  enum port_enum {r0 = 0, d0 = 1, r1 = 2, d1 = 3, r2 = 4, d2 = 5, r3 = 6, d3 = 7, r4 = 8, d4 = 9, r5 = 10, d5 = 11};

protected:
  friend class eth_model;

  /* parameters */
  sc_core::sc_time clock;
  sc_core::sc_time generic_clock;
  double nominal_voltage;
  bool verbose_parameters;
  bool dmi_enabled;
  const char* warning_level;
  const char* layers;
  const char* slave_sets;
  unsigned int write_broadcast;
  unsigned long long r0_base_address;
  unsigned long long r0_size;
  unsigned int r0_subtract_base_address;
  unsigned int r0_secure;
  const char* r0_additional_ranges;
  unsigned int r0_latency;
  unsigned int d0_priority;
  const char* d0_vmap;
  unsigned long long r1_base_address;
  unsigned long long r1_size;
  unsigned int r1_subtract_base_address;
  unsigned int r1_secure;
  const char* r1_additional_ranges;
  unsigned int r1_latency;
  unsigned int d1_priority;
  const char* d1_vmap;
  unsigned long long r2_base_address;
  unsigned long long r2_size;
  unsigned int r2_subtract_base_address;
  unsigned int r2_secure;
  const char* r2_additional_ranges;
  unsigned int r2_latency;
  unsigned int d2_priority;
  const char* d2_vmap;
  unsigned long long r3_base_address;
  unsigned long long r3_size;
  unsigned int r3_subtract_base_address;
  unsigned int r3_secure;
  const char* r3_additional_ranges;
  unsigned int r3_latency;
  unsigned int d3_priority;
  const char* d3_vmap;
  unsigned long long r4_base_address;
  unsigned long long r4_size;
  unsigned int r4_subtract_base_address;
  unsigned int r4_secure;
  const char* r4_additional_ranges;
  unsigned int r4_latency;
  unsigned int d4_priority;
  const char* d4_vmap;
  unsigned long long r5_base_address;
  unsigned long long r5_size;
  unsigned int r5_subtract_base_address;
  unsigned int r5_secure;
  const char* r5_additional_ranges;
  unsigned int r5_latency;
  unsigned int d5_priority;
  const char* d5_vmap;

protected:
  long m_simulation;
  
protected:
  void createDecoder(void* userRunningModel);
  
public:
  /* schedule functions */
  void schedule_generic_READ
    (long portIndex,
     sc_dt::uint64 delay,
     long& burstSize,
     esl::include::transaction_power& power , long ADDR, long* rDATA, long PRIORITY, long BURST, long SIZE, long STATUS);
  void schedule_generic_WRITE
    (long portIndex,
     sc_dt::uint64 delay,
     long& burstSize,
     esl::include::transaction_power& power , long ADDR, long* wDATA, long PRIORITY, long BURST, long SIZE, long STATUS);
public:
  /* called when "params.m_phase" is sent through the "port_index" port */
  virtual void sent_phase_cb(unsigned port_index,
                             esl::sc_sim::mb_cb_params& params) {
    sent_phase_cb(port_index, 
                  params.get_payload(), 
                  params.get_phase(), 
                  params.get_time());
  }
                             
  /* called when "params.m_phase" is received by the "port_index" port */
  virtual void received_phase_cb(unsigned port_index,
                                 esl::sc_sim::mb_cb_params& params) {
    received_phase_cb(port_index, 
                      params.get_payload(), 
                      params.get_phase(), 
                      params.get_time());
  }
                             
  /* called when "params.m_phase" is sent through the "master_port_index".
     "params.m_t" is the time (in ps) between the current time
     and the time "params.m_phase" was received by the "slave_port_index */
  virtual void forward_arbitration_cb(unsigned master_port_index,
                                        unsigned slave_port_index,
                                      esl::sc_sim::mb_cb_params& params) {
    forward_arbitration_cb(master_port_index, 
                           slave_port_index,
                           params.get_payload(), 
                           params.get_phase(), 
                           mb::sysc::sc_time_to_ps(params.get_time()));
  }

  /* called when "params.m_phase" is sent through the "slave_port_index".
     "params.m_t" is the time (in ps) between the current time
     and the time "params.m_phase" was received by the "master_port_index */
  virtual void backward_arbitration_cb(unsigned slave_port_index,
                                       unsigned master_port_index,
                                       esl::sc_sim::mb_cb_params& params) {
    backward_arbitration_cb(slave_port_index,
                            master_port_index,
                            params.get_payload(), 
                            params.get_phase(), 
                            mb::sysc::sc_time_to_ps(params.get_time()));
  }
                             

  /* old interface */
  
  virtual void sent_phase_cb(unsigned port_index,
                             tlm::tlm_generic_payload& trans,
                             tlm::tlm_phase& phase, sc_core::sc_time& t) {}
  
  virtual void received_phase_cb(unsigned port_index,
                             tlm::tlm_generic_payload& trans,
                                 tlm::tlm_phase& phase, sc_core::sc_time& t) {}
  
  virtual void forward_arbitration_cb(unsigned master_port_index,
                                      unsigned slave_port_index,
                                      tlm::tlm_generic_payload& trans,
                                      tlm::tlm_phase& phase,
                                      unsigned long long forward_arbitration_time) {}
  
  virtual void backward_arbitration_cb(unsigned slave_port_index,
                                       unsigned master_port_index,
                                       tlm::tlm_generic_payload& trans,
                                       tlm::tlm_phase& phase,
                                       unsigned long long backward_arbitration_time) {}

  // The following callbacks are called whenever there is a transaction start or end in the port

  virtual void accept_generic_READ
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 rDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) = 0;
  virtual void end_generic_READ
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 rDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) = 0;

  virtual void accept_generic_WRITE
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 wDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) = 0;
  virtual void end_generic_WRITE
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 ADDR,
     sc_dt::uint64 wDATA,
     sc_dt::uint64& PRIORITY,
     sc_dt::uint64& BURST,
     sc_dt::uint64 SIZE,
     sc_dt::uint64& STATUS) = 0;


protected:
  request_type* m_current_request;
private:
  static const unsigned port_count = 12;
  papoulis::SystemCBaseModel::PortDescription port_descriptions[port_count];

protected:
  virtual void vista_trace(bool isStart, request_type* request, long portIndex, sc_dt::uint64 startTime);
 protected:
  std::vector<esl::sc_sim::pipeline_policy*> m_pipeline_vector;
  std::vector<esl::sc_sim::delay_policy*> m_delay_vector;
  std::vector<esl::sc_sim::uniform_bus_policy*> m_bus_vector;
  std::vector<esl::sc_sim::power_policy*> m_power_vector;
  
  static const unsigned user_pipeline_policy_count = 36;
  papoulis::SystemCBaseModel::UserPipelinePolicyDescription user_pipeline_policy_descriptions[user_pipeline_policy_count];
 public:
  virtual void update_power_parameters(esl::sc_sim::power_policy* handle);
  virtual void update_delay_parameters(esl::sc_sim::delay_policy* handle);
  virtual void update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle);
  virtual void update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle);
public:
  virtual unsigned get_layer(unsigned port_index);
  virtual request_type* get_current_request();
  virtual unsigned get_slave_port_index();
  virtual bool portHasRegisters(unsigned portIndex) {return false;}
  
  virtual bool triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans) {
    return false;
  }

  virtual const char* get_library_name() {return "models";}
  virtual const char* get_model_vendor() {return "Mentor.com";}
  virtual const char* get_model_version() {return "1.0";}
  
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for eth.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.2.0
//* Generated on: Aug. 12, 2016 10:08:50 AM, (user: jon)
//*>


#pragma once

#include "model_builder.h"



 


// forward declaration for pv class
class eth_pv;



using namespace std;

class eth_pvt_param_defaults {
  
public:
  eth_pvt_param_defaults(const char* hier_name) {

    sc_core::sc_time clock;
    sc_core::sc_time generic_clock;
    double nominal_voltage;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    const char* layers;
    const char* slave_sets;
    unsigned int write_broadcast;
    unsigned long long r0_base_address;
    unsigned long long r0_size;
    unsigned int r0_subtract_base_address;
    unsigned int r0_secure;
    const char* r0_additional_ranges;
    unsigned int r0_latency;
    unsigned int d0_priority;
    const char* d0_vmap;
    unsigned long long r1_base_address;
    unsigned long long r1_size;
    unsigned int r1_subtract_base_address;
    unsigned int r1_secure;
    const char* r1_additional_ranges;
    unsigned int r1_latency;
    unsigned int d1_priority;
    const char* d1_vmap;
    unsigned long long r2_base_address;
    unsigned long long r2_size;
    unsigned int r2_subtract_base_address;
    unsigned int r2_secure;
    const char* r2_additional_ranges;
    unsigned int r2_latency;
    unsigned int d2_priority;
    const char* d2_vmap;
    unsigned long long r3_base_address;
    unsigned long long r3_size;
    unsigned int r3_subtract_base_address;
    unsigned int r3_secure;
    const char* r3_additional_ranges;
    unsigned int r3_latency;
    unsigned int d3_priority;
    const char* d3_vmap;
    unsigned long long r4_base_address;
    unsigned long long r4_size;
    unsigned int r4_subtract_base_address;
    unsigned int r4_secure;
    const char* r4_additional_ranges;
    unsigned int r4_latency;
    unsigned int d4_priority;
    const char* d4_vmap;
    unsigned long long r5_base_address;
    unsigned long long r5_size;
    unsigned int r5_subtract_base_address;
    unsigned int r5_secure;
    const char* r5_additional_ranges;
    unsigned int r5_latency;
    unsigned int d5_priority;
    const char* d5_vmap;
    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    generic_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("generic_clock", clock, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", 1, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", true, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", true, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", "WARNING", hier_name);
    layers = ::mb::sysc::sdInitParameter<const char*>("layers", "", hier_name);
    slave_sets = ::mb::sysc::sdInitParameter<const char*>("slave_sets", "", hier_name);
    write_broadcast = ::mb::sysc::sdInitParameter<unsigned int>("write_broadcast", 1, hier_name);
    r0_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r0_base_address", 0, hier_name);
    r0_size = ::mb::sysc::sdInitParameter<unsigned long long>("r0_size", 0xFFFFFFFF, hier_name);
    r0_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r0_subtract_base_address", 1, hier_name);
    r0_secure = ::mb::sysc::sdInitParameter<unsigned int>("r0_secure", 0, hier_name);
    r0_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r0_additional_ranges", "", hier_name);
    r0_latency = ::mb::sysc::sdInitParameter<unsigned int>("r0_latency", 0, hier_name);
    d0_priority = ::mb::sysc::sdInitParameter<unsigned int>("d0_priority", 0, hier_name);
    d0_vmap = ::mb::sysc::sdInitParameter<const char*>("d0_vmap", "", hier_name);
    r1_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r1_base_address", 0, hier_name);
    r1_size = ::mb::sysc::sdInitParameter<unsigned long long>("r1_size", 0xFFFFFFFF, hier_name);
    r1_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r1_subtract_base_address", 1, hier_name);
    r1_secure = ::mb::sysc::sdInitParameter<unsigned int>("r1_secure", 0, hier_name);
    r1_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r1_additional_ranges", "", hier_name);
    r1_latency = ::mb::sysc::sdInitParameter<unsigned int>("r1_latency", 0, hier_name);
    d1_priority = ::mb::sysc::sdInitParameter<unsigned int>("d1_priority", 0, hier_name);
    d1_vmap = ::mb::sysc::sdInitParameter<const char*>("d1_vmap", "", hier_name);
    r2_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r2_base_address", 0, hier_name);
    r2_size = ::mb::sysc::sdInitParameter<unsigned long long>("r2_size", 0xFFFFFFFF, hier_name);
    r2_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r2_subtract_base_address", 1, hier_name);
    r2_secure = ::mb::sysc::sdInitParameter<unsigned int>("r2_secure", 0, hier_name);
    r2_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r2_additional_ranges", "", hier_name);
    r2_latency = ::mb::sysc::sdInitParameter<unsigned int>("r2_latency", 0, hier_name);
    d2_priority = ::mb::sysc::sdInitParameter<unsigned int>("d2_priority", 0, hier_name);
    d2_vmap = ::mb::sysc::sdInitParameter<const char*>("d2_vmap", "", hier_name);
    r3_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r3_base_address", 0, hier_name);
    r3_size = ::mb::sysc::sdInitParameter<unsigned long long>("r3_size", 0xFFFFFFFF, hier_name);
    r3_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r3_subtract_base_address", 1, hier_name);
    r3_secure = ::mb::sysc::sdInitParameter<unsigned int>("r3_secure", 0, hier_name);
    r3_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r3_additional_ranges", "", hier_name);
    r3_latency = ::mb::sysc::sdInitParameter<unsigned int>("r3_latency", 0, hier_name);
    d3_priority = ::mb::sysc::sdInitParameter<unsigned int>("d3_priority", 0, hier_name);
    d3_vmap = ::mb::sysc::sdInitParameter<const char*>("d3_vmap", "", hier_name);
    r4_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r4_base_address", 0, hier_name);
    r4_size = ::mb::sysc::sdInitParameter<unsigned long long>("r4_size", 0xFFFFFFFF, hier_name);
    r4_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r4_subtract_base_address", 1, hier_name);
    r4_secure = ::mb::sysc::sdInitParameter<unsigned int>("r4_secure", 0, hier_name);
    r4_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r4_additional_ranges", "", hier_name);
    r4_latency = ::mb::sysc::sdInitParameter<unsigned int>("r4_latency", 0, hier_name);
    d4_priority = ::mb::sysc::sdInitParameter<unsigned int>("d4_priority", 0, hier_name);
    d4_vmap = ::mb::sysc::sdInitParameter<const char*>("d4_vmap", "", hier_name);
    r5_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r5_base_address", 0, hier_name);
    r5_size = ::mb::sysc::sdInitParameter<unsigned long long>("r5_size", 0xFFFFFFFF, hier_name);
    r5_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r5_subtract_base_address", 1, hier_name);
    r5_secure = ::mb::sysc::sdInitParameter<unsigned int>("r5_secure", 0, hier_name);
    r5_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r5_additional_ranges", "", hier_name);
    r5_latency = ::mb::sysc::sdInitParameter<unsigned int>("r5_latency", 0, hier_name);
    d5_priority = ::mb::sysc::sdInitParameter<unsigned int>("d5_priority", 0, hier_name);
    d5_vmap = ::mb::sysc::sdInitParameter<const char*>("d5_vmap", "", hier_name);
    ::mb::sysc::sdPropagateParameters();
  }

  eth_pvt_param_defaults(const char* hier_name, sc_core::sc_time clock_init, sc_core::sc_time generic_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, const char* layers_init, const char* slave_sets_init, unsigned int write_broadcast_init, unsigned long long r0_base_address_init, unsigned long long r0_size_init, unsigned int r0_subtract_base_address_init, unsigned int r0_secure_init, const char* r0_additional_ranges_init, unsigned int r0_latency_init, unsigned int d0_priority_init, const char* d0_vmap_init, unsigned long long r1_base_address_init, unsigned long long r1_size_init, unsigned int r1_subtract_base_address_init, unsigned int r1_secure_init, const char* r1_additional_ranges_init, unsigned int r1_latency_init, unsigned int d1_priority_init, const char* d1_vmap_init, unsigned long long r2_base_address_init, unsigned long long r2_size_init, unsigned int r2_subtract_base_address_init, unsigned int r2_secure_init, const char* r2_additional_ranges_init, unsigned int r2_latency_init, unsigned int d2_priority_init, const char* d2_vmap_init, unsigned long long r3_base_address_init, unsigned long long r3_size_init, unsigned int r3_subtract_base_address_init, unsigned int r3_secure_init, const char* r3_additional_ranges_init, unsigned int r3_latency_init, unsigned int d3_priority_init, const char* d3_vmap_init, unsigned long long r4_base_address_init, unsigned long long r4_size_init, unsigned int r4_subtract_base_address_init, unsigned int r4_secure_init, const char* r4_additional_ranges_init, unsigned int r4_latency_init, unsigned int d4_priority_init, const char* d4_vmap_init, unsigned long long r5_base_address_init, unsigned long long r5_size_init, unsigned int r5_subtract_base_address_init, unsigned int r5_secure_init, const char* r5_additional_ranges_init, unsigned int r5_latency_init, unsigned int d5_priority_init, const char* d5_vmap_init) {

    sc_core::sc_time clock;
    sc_core::sc_time generic_clock;
    double nominal_voltage;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    const char* layers;
    const char* slave_sets;
    unsigned int write_broadcast;
    unsigned long long r0_base_address;
    unsigned long long r0_size;
    unsigned int r0_subtract_base_address;
    unsigned int r0_secure;
    const char* r0_additional_ranges;
    unsigned int r0_latency;
    unsigned int d0_priority;
    const char* d0_vmap;
    unsigned long long r1_base_address;
    unsigned long long r1_size;
    unsigned int r1_subtract_base_address;
    unsigned int r1_secure;
    const char* r1_additional_ranges;
    unsigned int r1_latency;
    unsigned int d1_priority;
    const char* d1_vmap;
    unsigned long long r2_base_address;
    unsigned long long r2_size;
    unsigned int r2_subtract_base_address;
    unsigned int r2_secure;
    const char* r2_additional_ranges;
    unsigned int r2_latency;
    unsigned int d2_priority;
    const char* d2_vmap;
    unsigned long long r3_base_address;
    unsigned long long r3_size;
    unsigned int r3_subtract_base_address;
    unsigned int r3_secure;
    const char* r3_additional_ranges;
    unsigned int r3_latency;
    unsigned int d3_priority;
    const char* d3_vmap;
    unsigned long long r4_base_address;
    unsigned long long r4_size;
    unsigned int r4_subtract_base_address;
    unsigned int r4_secure;
    const char* r4_additional_ranges;
    unsigned int r4_latency;
    unsigned int d4_priority;
    const char* d4_vmap;
    unsigned long long r5_base_address;
    unsigned long long r5_size;
    unsigned int r5_subtract_base_address;
    unsigned int r5_secure;
    const char* r5_additional_ranges;
    unsigned int r5_latency;
    unsigned int d5_priority;
    const char* d5_vmap;
    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", clock_init, hier_name);
    generic_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("generic_clock", generic_clock_init, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", nominal_voltage_init, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", verbose_parameters_init, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", dmi_enabled_init, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", warning_level_init, hier_name);
    layers = ::mb::sysc::sdInitParameter<const char*>("layers", layers_init, hier_name);
    slave_sets = ::mb::sysc::sdInitParameter<const char*>("slave_sets", slave_sets_init, hier_name);
    write_broadcast = ::mb::sysc::sdInitParameter<unsigned int>("write_broadcast", write_broadcast_init, hier_name);
    r0_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r0_base_address", r0_base_address_init, hier_name);
    r0_size = ::mb::sysc::sdInitParameter<unsigned long long>("r0_size", r0_size_init, hier_name);
    r0_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r0_subtract_base_address", r0_subtract_base_address_init, hier_name);
    r0_secure = ::mb::sysc::sdInitParameter<unsigned int>("r0_secure", r0_secure_init, hier_name);
    r0_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r0_additional_ranges", r0_additional_ranges_init, hier_name);
    r0_latency = ::mb::sysc::sdInitParameter<unsigned int>("r0_latency", r0_latency_init, hier_name);
    d0_priority = ::mb::sysc::sdInitParameter<unsigned int>("d0_priority", d0_priority_init, hier_name);
    d0_vmap = ::mb::sysc::sdInitParameter<const char*>("d0_vmap", d0_vmap_init, hier_name);
    r1_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r1_base_address", r1_base_address_init, hier_name);
    r1_size = ::mb::sysc::sdInitParameter<unsigned long long>("r1_size", r1_size_init, hier_name);
    r1_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r1_subtract_base_address", r1_subtract_base_address_init, hier_name);
    r1_secure = ::mb::sysc::sdInitParameter<unsigned int>("r1_secure", r1_secure_init, hier_name);
    r1_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r1_additional_ranges", r1_additional_ranges_init, hier_name);
    r1_latency = ::mb::sysc::sdInitParameter<unsigned int>("r1_latency", r1_latency_init, hier_name);
    d1_priority = ::mb::sysc::sdInitParameter<unsigned int>("d1_priority", d1_priority_init, hier_name);
    d1_vmap = ::mb::sysc::sdInitParameter<const char*>("d1_vmap", d1_vmap_init, hier_name);
    r2_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r2_base_address", r2_base_address_init, hier_name);
    r2_size = ::mb::sysc::sdInitParameter<unsigned long long>("r2_size", r2_size_init, hier_name);
    r2_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r2_subtract_base_address", r2_subtract_base_address_init, hier_name);
    r2_secure = ::mb::sysc::sdInitParameter<unsigned int>("r2_secure", r2_secure_init, hier_name);
    r2_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r2_additional_ranges", r2_additional_ranges_init, hier_name);
    r2_latency = ::mb::sysc::sdInitParameter<unsigned int>("r2_latency", r2_latency_init, hier_name);
    d2_priority = ::mb::sysc::sdInitParameter<unsigned int>("d2_priority", d2_priority_init, hier_name);
    d2_vmap = ::mb::sysc::sdInitParameter<const char*>("d2_vmap", d2_vmap_init, hier_name);
    r3_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r3_base_address", r3_base_address_init, hier_name);
    r3_size = ::mb::sysc::sdInitParameter<unsigned long long>("r3_size", r3_size_init, hier_name);
    r3_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r3_subtract_base_address", r3_subtract_base_address_init, hier_name);
    r3_secure = ::mb::sysc::sdInitParameter<unsigned int>("r3_secure", r3_secure_init, hier_name);
    r3_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r3_additional_ranges", r3_additional_ranges_init, hier_name);
    r3_latency = ::mb::sysc::sdInitParameter<unsigned int>("r3_latency", r3_latency_init, hier_name);
    d3_priority = ::mb::sysc::sdInitParameter<unsigned int>("d3_priority", d3_priority_init, hier_name);
    d3_vmap = ::mb::sysc::sdInitParameter<const char*>("d3_vmap", d3_vmap_init, hier_name);
    r4_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r4_base_address", r4_base_address_init, hier_name);
    r4_size = ::mb::sysc::sdInitParameter<unsigned long long>("r4_size", r4_size_init, hier_name);
    r4_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r4_subtract_base_address", r4_subtract_base_address_init, hier_name);
    r4_secure = ::mb::sysc::sdInitParameter<unsigned int>("r4_secure", r4_secure_init, hier_name);
    r4_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r4_additional_ranges", r4_additional_ranges_init, hier_name);
    r4_latency = ::mb::sysc::sdInitParameter<unsigned int>("r4_latency", r4_latency_init, hier_name);
    d4_priority = ::mb::sysc::sdInitParameter<unsigned int>("d4_priority", d4_priority_init, hier_name);
    d4_vmap = ::mb::sysc::sdInitParameter<const char*>("d4_vmap", d4_vmap_init, hier_name);
    r5_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r5_base_address", r5_base_address_init, hier_name);
    r5_size = ::mb::sysc::sdInitParameter<unsigned long long>("r5_size", r5_size_init, hier_name);
    r5_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r5_subtract_base_address", r5_subtract_base_address_init, hier_name);
    r5_secure = ::mb::sysc::sdInitParameter<unsigned int>("r5_secure", r5_secure_init, hier_name);
    r5_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r5_additional_ranges", r5_additional_ranges_init, hier_name);
    r5_latency = ::mb::sysc::sdInitParameter<unsigned int>("r5_latency", r5_latency_init, hier_name);
    d5_priority = ::mb::sysc::sdInitParameter<unsigned int>("d5_priority", d5_priority_init, hier_name);
    d5_vmap = ::mb::sysc::sdInitParameter<const char*>("d5_vmap", d5_vmap_init, hier_name);

    ::mb::sysc::sdPropagateParameters();
    }

  eth_pvt_param_defaults(const char* hier_name, std::vector<std::pair<char*, unsigned int> > &change_parameters){

    sc_core::sc_time clock;
    sc_core::sc_time generic_clock;
    double nominal_voltage;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    const char* layers;
    const char* slave_sets;
    unsigned int write_broadcast;
    unsigned long long r0_base_address;
    unsigned long long r0_size;
    unsigned int r0_subtract_base_address;
    unsigned int r0_secure;
    const char* r0_additional_ranges;
    unsigned int r0_latency;
    unsigned int d0_priority;
    const char* d0_vmap;
    unsigned long long r1_base_address;
    unsigned long long r1_size;
    unsigned int r1_subtract_base_address;
    unsigned int r1_secure;
    const char* r1_additional_ranges;
    unsigned int r1_latency;
    unsigned int d1_priority;
    const char* d1_vmap;
    unsigned long long r2_base_address;
    unsigned long long r2_size;
    unsigned int r2_subtract_base_address;
    unsigned int r2_secure;
    const char* r2_additional_ranges;
    unsigned int r2_latency;
    unsigned int d2_priority;
    const char* d2_vmap;
    unsigned long long r3_base_address;
    unsigned long long r3_size;
    unsigned int r3_subtract_base_address;
    unsigned int r3_secure;
    const char* r3_additional_ranges;
    unsigned int r3_latency;
    unsigned int d3_priority;
    const char* d3_vmap;
    unsigned long long r4_base_address;
    unsigned long long r4_size;
    unsigned int r4_subtract_base_address;
    unsigned int r4_secure;
    const char* r4_additional_ranges;
    unsigned int r4_latency;
    unsigned int d4_priority;
    const char* d4_vmap;
    unsigned long long r5_base_address;
    unsigned long long r5_size;
    unsigned int r5_subtract_base_address;
    unsigned int r5_secure;
    const char* r5_additional_ranges;
    unsigned int r5_latency;
    unsigned int d5_priority;
    const char* d5_vmap;
    for (unsigned i =0; i<change_parameters.size(); i++){
      ::mb::sysc::sdInitParameter<unsigned int>(change_parameters[i].first, change_parameters[i].second, hier_name);
    }

    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    generic_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("generic_clock", clock, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", 1, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", true, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", true, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", "WARNING", hier_name);
    layers = ::mb::sysc::sdInitParameter<const char*>("layers", "", hier_name);
    slave_sets = ::mb::sysc::sdInitParameter<const char*>("slave_sets", "", hier_name);
    write_broadcast = ::mb::sysc::sdInitParameter<unsigned int>("write_broadcast", 1, hier_name);
    r0_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r0_base_address", 0, hier_name);
    r0_size = ::mb::sysc::sdInitParameter<unsigned long long>("r0_size", 0xFFFFFFFF, hier_name);
    r0_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r0_subtract_base_address", 1, hier_name);
    r0_secure = ::mb::sysc::sdInitParameter<unsigned int>("r0_secure", 0, hier_name);
    r0_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r0_additional_ranges", "", hier_name);
    r0_latency = ::mb::sysc::sdInitParameter<unsigned int>("r0_latency", 0, hier_name);
    d0_priority = ::mb::sysc::sdInitParameter<unsigned int>("d0_priority", 0, hier_name);
    d0_vmap = ::mb::sysc::sdInitParameter<const char*>("d0_vmap", "", hier_name);
    r1_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r1_base_address", 0, hier_name);
    r1_size = ::mb::sysc::sdInitParameter<unsigned long long>("r1_size", 0xFFFFFFFF, hier_name);
    r1_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r1_subtract_base_address", 1, hier_name);
    r1_secure = ::mb::sysc::sdInitParameter<unsigned int>("r1_secure", 0, hier_name);
    r1_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r1_additional_ranges", "", hier_name);
    r1_latency = ::mb::sysc::sdInitParameter<unsigned int>("r1_latency", 0, hier_name);
    d1_priority = ::mb::sysc::sdInitParameter<unsigned int>("d1_priority", 0, hier_name);
    d1_vmap = ::mb::sysc::sdInitParameter<const char*>("d1_vmap", "", hier_name);
    r2_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r2_base_address", 0, hier_name);
    r2_size = ::mb::sysc::sdInitParameter<unsigned long long>("r2_size", 0xFFFFFFFF, hier_name);
    r2_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r2_subtract_base_address", 1, hier_name);
    r2_secure = ::mb::sysc::sdInitParameter<unsigned int>("r2_secure", 0, hier_name);
    r2_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r2_additional_ranges", "", hier_name);
    r2_latency = ::mb::sysc::sdInitParameter<unsigned int>("r2_latency", 0, hier_name);
    d2_priority = ::mb::sysc::sdInitParameter<unsigned int>("d2_priority", 0, hier_name);
    d2_vmap = ::mb::sysc::sdInitParameter<const char*>("d2_vmap", "", hier_name);
    r3_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r3_base_address", 0, hier_name);
    r3_size = ::mb::sysc::sdInitParameter<unsigned long long>("r3_size", 0xFFFFFFFF, hier_name);
    r3_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r3_subtract_base_address", 1, hier_name);
    r3_secure = ::mb::sysc::sdInitParameter<unsigned int>("r3_secure", 0, hier_name);
    r3_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r3_additional_ranges", "", hier_name);
    r3_latency = ::mb::sysc::sdInitParameter<unsigned int>("r3_latency", 0, hier_name);
    d3_priority = ::mb::sysc::sdInitParameter<unsigned int>("d3_priority", 0, hier_name);
    d3_vmap = ::mb::sysc::sdInitParameter<const char*>("d3_vmap", "", hier_name);
    r4_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r4_base_address", 0, hier_name);
    r4_size = ::mb::sysc::sdInitParameter<unsigned long long>("r4_size", 0xFFFFFFFF, hier_name);
    r4_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r4_subtract_base_address", 1, hier_name);
    r4_secure = ::mb::sysc::sdInitParameter<unsigned int>("r4_secure", 0, hier_name);
    r4_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r4_additional_ranges", "", hier_name);
    r4_latency = ::mb::sysc::sdInitParameter<unsigned int>("r4_latency", 0, hier_name);
    d4_priority = ::mb::sysc::sdInitParameter<unsigned int>("d4_priority", 0, hier_name);
    d4_vmap = ::mb::sysc::sdInitParameter<const char*>("d4_vmap", "", hier_name);
    r5_base_address = ::mb::sysc::sdInitParameter<unsigned long long>("r5_base_address", 0, hier_name);
    r5_size = ::mb::sysc::sdInitParameter<unsigned long long>("r5_size", 0xFFFFFFFF, hier_name);
    r5_subtract_base_address = ::mb::sysc::sdInitParameter<unsigned int>("r5_subtract_base_address", 1, hier_name);
    r5_secure = ::mb::sysc::sdInitParameter<unsigned int>("r5_secure", 0, hier_name);
    r5_additional_ranges = ::mb::sysc::sdInitParameter<const char*>("r5_additional_ranges", "", hier_name);
    r5_latency = ::mb::sysc::sdInitParameter<unsigned int>("r5_latency", 0, hier_name);
    d5_priority = ::mb::sysc::sdInitParameter<unsigned int>("d5_priority", 0, hier_name);
    d5_vmap = ::mb::sysc::sdInitParameter<const char*>("d5_vmap", "", hier_name);  

    ::mb::sysc::sdPropagateParameters();
  }
  
  //void set_clock (

};

class eth_pvt : public esl::sc_sim::PVTBaseModel, 
                          public mb::utl::cb_owner,
                          private eth_pvt_param_defaults {

 public:
  typedef eth_pvt self_type;

 public: 
  // Constructor
  eth_pvt(sc_core::sc_module_name module_name); 
  eth_pvt(sc_core::sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time generic_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, const char* layers_init, const char* slave_sets_init, unsigned int write_broadcast_init, unsigned long long r0_base_address_init, unsigned long long r0_size_init, unsigned int r0_subtract_base_address_init, unsigned int r0_secure_init, const char* r0_additional_ranges_init, unsigned int r0_latency_init, unsigned int d0_priority_init, const char* d0_vmap_init, unsigned long long r1_base_address_init, unsigned long long r1_size_init, unsigned int r1_subtract_base_address_init, unsigned int r1_secure_init, const char* r1_additional_ranges_init, unsigned int r1_latency_init, unsigned int d1_priority_init, const char* d1_vmap_init, unsigned long long r2_base_address_init, unsigned long long r2_size_init, unsigned int r2_subtract_base_address_init, unsigned int r2_secure_init, const char* r2_additional_ranges_init, unsigned int r2_latency_init, unsigned int d2_priority_init, const char* d2_vmap_init, unsigned long long r3_base_address_init, unsigned long long r3_size_init, unsigned int r3_subtract_base_address_init, unsigned int r3_secure_init, const char* r3_additional_ranges_init, unsigned int r3_latency_init, unsigned int d3_priority_init, const char* d3_vmap_init, unsigned long long r4_base_address_init, unsigned long long r4_size_init, unsigned int r4_subtract_base_address_init, unsigned int r4_secure_init, const char* r4_additional_ranges_init, unsigned int r4_latency_init, unsigned int d4_priority_init, const char* d4_vmap_init, unsigned long long r5_base_address_init, unsigned long long r5_size_init, unsigned int r5_subtract_base_address_init, unsigned int r5_secure_init, const char* r5_additional_ranges_init, unsigned int r5_latency_init, unsigned int d5_priority_init, const char* d5_vmap_init); 
  eth_pvt(sc_core::sc_module_name module_name, std::vector<std::pair<char*, unsigned int> > &change_parameters);
  ~eth_pvt(); 

 
 public:
    //access the T instance
  inline eth_t_base* getT() const {
    return m_eth_t;
  }
  
  //access the PV instance
  inline eth_pv* getPV() const {
    return m_eth_pv;
  }

  virtual const SystemCBaseModel* getSystemCBaseModel() const {
    return getT();
  }
  virtual SystemCBaseModel* getSystemCBaseModel() {
    return getT();
  }
  

 private:
  void bind();
  

  void b_transport_outside_r0(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_r0(tlm::tlm_generic_payload& p);
  void b_transport_outside_r1(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_r1(tlm::tlm_generic_payload& p);
  void b_transport_outside_r2(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_r2(tlm::tlm_generic_payload& p);
  void b_transport_outside_r3(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_r3(tlm::tlm_generic_payload& p);
  void b_transport_outside_r4(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_r4(tlm::tlm_generic_payload& p);
  void b_transport_outside_r5(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_r5(tlm::tlm_generic_payload& p); 

 private:
  
  //T instance
  eth_t_base* m_eth_t;
  
  //PV instance
  eth_pv* m_eth_pv;

 public:
  // External ports

  typedef mb::tlm20::interface_initiator_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> r0_type;
  r0_type r0;
  typedef mb::tlm20::interface_initiator_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> r1_type;
  r1_type r1;
  typedef mb::tlm20::interface_initiator_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> r2_type;
  r2_type r2;
  typedef mb::tlm20::interface_initiator_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> r3_type;
  r3_type r3;
  typedef mb::tlm20::interface_initiator_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> r4_type;
  r4_type r4;
  typedef mb::tlm20::interface_initiator_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> r5_type;
  r5_type r5;
  typedef mb::tlm20::interface_target_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> d0_type;
  d0_type d0;
  typedef mb::tlm20::interface_target_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> d1_type;
  d1_type d1;
  typedef mb::tlm20::interface_target_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> d2_type;
  d2_type d2;
  typedef mb::tlm20::interface_target_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> d3_type;
  d3_type d3;
  typedef mb::tlm20::interface_target_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> d4_type;
  d4_type d4;
  typedef mb::tlm20::interface_target_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> d5_type;
  d5_type d5;

 private:
  // PV connection ports

  typedef mb::tlm20::target_socket_cb<32> r0_entry_type;
  r0_entry_type r0_entry;
  typedef mb::tlm20::target_socket_cb<32> r1_entry_type;
  r1_entry_type r1_entry;
  typedef mb::tlm20::target_socket_cb<32> r2_entry_type;
  r2_entry_type r2_entry;
  typedef mb::tlm20::target_socket_cb<32> r3_entry_type;
  r3_entry_type r3_entry;
  typedef mb::tlm20::target_socket_cb<32> r4_entry_type;
  r4_entry_type r4_entry;
  typedef mb::tlm20::target_socket_cb<32> r5_entry_type;
  r5_entry_type r5_entry;
  typedef mb::tlm20::initiator_socket_cb<32> d0_entry_type;
  d0_entry_type d0_entry;
  typedef mb::tlm20::initiator_socket_cb<32> d1_entry_type;
  d1_entry_type d1_entry;
  typedef mb::tlm20::initiator_socket_cb<32> d2_entry_type;
  d2_entry_type d2_entry;
  typedef mb::tlm20::initiator_socket_cb<32> d3_entry_type;
  d3_entry_type d3_entry;
  typedef mb::tlm20::initiator_socket_cb<32> d4_entry_type;
  d4_entry_type d4_entry;
  typedef mb::tlm20::initiator_socket_cb<32> d5_entry_type;
  d5_entry_type d5_entry;      

 public:
  sc_core::sc_time r0_time;

  sc_core::sc_time r1_time;

  sc_core::sc_time r2_time;

  sc_core::sc_time r3_time;

  sc_core::sc_time r4_time;

  sc_core::sc_time r5_time;


 private:

  struct r0_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    r0_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.r0.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.r0;
    }
  };
  friend struct r0_nb_connector;
  r0_nb_connector m_r0_nb_connector;

  struct r1_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    r1_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.r1.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.r1;
    }
  };
  friend struct r1_nb_connector;
  r1_nb_connector m_r1_nb_connector;

  struct r2_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    r2_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.r2.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.r2;
    }
  };
  friend struct r2_nb_connector;
  r2_nb_connector m_r2_nb_connector;

  struct r3_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    r3_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.r3.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.r3;
    }
  };
  friend struct r3_nb_connector;
  r3_nb_connector m_r3_nb_connector;

  struct r4_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    r4_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.r4.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.r4;
    }
  };
  friend struct r4_nb_connector;
  r4_nb_connector m_r4_nb_connector;

  struct r5_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    r5_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.r5.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.r5;
    }
  };
  friend struct r5_nb_connector;
  r5_nb_connector m_r5_nb_connector;



  struct d0_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    d0_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.d0.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.d0;
    }
  };
  friend struct d0_nb_connector;
  d0_nb_connector m_d0_nb_connector;

  struct d1_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    d1_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.d1.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.d1;
    }
  };
  friend struct d1_nb_connector;
  d1_nb_connector m_d1_nb_connector;

  struct d2_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    d2_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.d2.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.d2;
    }
  };
  friend struct d2_nb_connector;
  d2_nb_connector m_d2_nb_connector;

  struct d3_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    d3_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.d3.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.d3;
    }
  };
  friend struct d3_nb_connector;
  d3_nb_connector m_d3_nb_connector;

  struct d4_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    d4_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.d4.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.d4;
    }
  };
  friend struct d4_nb_connector;
  d4_nb_connector m_d4_nb_connector;

  struct d5_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    eth_pvt& m_owner;
    
    d5_nb_connector(eth_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.d5.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.d5;
    }
  };
  friend struct d5_nb_connector;
  d5_nb_connector m_d5_nb_connector;

  

  tlm::tlm_sync_enum receive_nb_transport_r0(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(0, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_r1(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(2, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_r2(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(4, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_r3(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(6, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_r4(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(8, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_r5(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(10, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_d0(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(1, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_d1(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(3, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_d2(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(5, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_d3(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(7, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_d4(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(9, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_d5(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(11, trans, phase, t);
  }

};



