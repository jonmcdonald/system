
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The eth_pv will be derived from this class.
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 12, 2016 03:01:29 PM, (user: jon)
//*>


#include "eth_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4201 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.2.1. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


eth_pv_base::eth_pv_base(sc_module_name& module_name) : 
  eth_pv_base_mb_compatibility(module_name),
  eth_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(r0),
  VISTA_MB_PV_INIT_MEMBER(r1),
  VISTA_MB_PV_INIT_MEMBER(r2),
  VISTA_MB_PV_INIT_MEMBER(r3),
  VISTA_MB_PV_INIT_MEMBER(r4),
  VISTA_MB_PV_INIT_MEMBER(r5),
  VISTA_MB_PV_INIT_MEMBER(d0),
  VISTA_MB_PV_INIT_MEMBER(d1),
  VISTA_MB_PV_INIT_MEMBER(d2),
  VISTA_MB_PV_INIT_MEMBER(d3),
  VISTA_MB_PV_INIT_MEMBER(d4),
  VISTA_MB_PV_INIT_MEMBER(d5) {
  

  // r0 - not a vector port
  // r1 - not a vector port
  // r2 - not a vector port
  // r3 - not a vector port
  // r4 - not a vector port
  // r5 - not a vector port
  // d0 - not a vector port
  // d1 - not a vector port
  // d2 - not a vector port
  // d3 - not a vector port
  // d4 - not a vector port
  // d5 - not a vector port
  unsigned u = 0;


  payload_on_stack = 0;
  payload_for_token = 0;
  reset_registers();
  
  // reset value for output signals

  // reset value for input signals

  // d0 bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(d0);
  // d1 bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(d1);
  // d2 bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(d2);
  // d3 bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(d3);
  // d4 bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(d4);
  // d5 bw binding 
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(d5);
  // r0 bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(r0);
  // r1 bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(r1);
  // r2 bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(r2);
  // r3 bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(r3);
  // r4 bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(r4);
  // r5 bw binding 
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(r5);
  // d0 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(d0);
  // d1 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(d1);
  // d2 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(d2);
  // d3 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(d3);
  // d4 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(d4);
  // d5 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(d5);
  // r0 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(r0);
  // r1 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(r1);
  // r2 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(r2);
  // r3 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(r3);
  // r4 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(r4);
  // r5 bw callbacks 
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(r5);

}

void eth_pv_base::reset_registers() {
  // reset all registers
  unsigned u = 0;


}

void eth_pv_base::reset_model() {
  
  reset_registers();
  // reset value for output signals

  // reset value for input signals

}

eth_pv_base_parameters::eth_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, generic_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, layers, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_sets, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, write_broadcast, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r0_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r0_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r0_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r0_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r0_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r0_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d0_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d0_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r1_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r1_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r1_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r1_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r1_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r1_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d1_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d1_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r2_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r2_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r2_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r2_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r2_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r2_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d2_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d2_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r3_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r3_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r3_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r3_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r3_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r3_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d3_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d3_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r4_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r4_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r4_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r4_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r4_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r4_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d4_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d4_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r5_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r5_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r5_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r5_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r5_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, r5_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d5_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, d5_vmap, "")
{
  if(verbose_parameters) print_parameters();
}

void eth_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\tgeneric_clock = " << generic_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tlayers = " << layers << "\n";
  std::cout << "\tslave_sets = " << slave_sets << "\n";
  std::cout << "\twrite_broadcast = " << write_broadcast << "\n";
  std::cout << "\tr0_base_address = " << r0_base_address << "\n";
  std::cout << "\tr0_size = " << r0_size << "\n";
  std::cout << "\tr0_subtract_base_address = " << r0_subtract_base_address << "\n";
  std::cout << "\tr0_secure = " << r0_secure << "\n";
  std::cout << "\tr0_additional_ranges = " << r0_additional_ranges << "\n";
  std::cout << "\tr0_latency = " << r0_latency << "\n";
  std::cout << "\td0_priority = " << d0_priority << "\n";
  std::cout << "\td0_vmap = " << d0_vmap << "\n";
  std::cout << "\tr1_base_address = " << r1_base_address << "\n";
  std::cout << "\tr1_size = " << r1_size << "\n";
  std::cout << "\tr1_subtract_base_address = " << r1_subtract_base_address << "\n";
  std::cout << "\tr1_secure = " << r1_secure << "\n";
  std::cout << "\tr1_additional_ranges = " << r1_additional_ranges << "\n";
  std::cout << "\tr1_latency = " << r1_latency << "\n";
  std::cout << "\td1_priority = " << d1_priority << "\n";
  std::cout << "\td1_vmap = " << d1_vmap << "\n";
  std::cout << "\tr2_base_address = " << r2_base_address << "\n";
  std::cout << "\tr2_size = " << r2_size << "\n";
  std::cout << "\tr2_subtract_base_address = " << r2_subtract_base_address << "\n";
  std::cout << "\tr2_secure = " << r2_secure << "\n";
  std::cout << "\tr2_additional_ranges = " << r2_additional_ranges << "\n";
  std::cout << "\tr2_latency = " << r2_latency << "\n";
  std::cout << "\td2_priority = " << d2_priority << "\n";
  std::cout << "\td2_vmap = " << d2_vmap << "\n";
  std::cout << "\tr3_base_address = " << r3_base_address << "\n";
  std::cout << "\tr3_size = " << r3_size << "\n";
  std::cout << "\tr3_subtract_base_address = " << r3_subtract_base_address << "\n";
  std::cout << "\tr3_secure = " << r3_secure << "\n";
  std::cout << "\tr3_additional_ranges = " << r3_additional_ranges << "\n";
  std::cout << "\tr3_latency = " << r3_latency << "\n";
  std::cout << "\td3_priority = " << d3_priority << "\n";
  std::cout << "\td3_vmap = " << d3_vmap << "\n";
  std::cout << "\tr4_base_address = " << r4_base_address << "\n";
  std::cout << "\tr4_size = " << r4_size << "\n";
  std::cout << "\tr4_subtract_base_address = " << r4_subtract_base_address << "\n";
  std::cout << "\tr4_secure = " << r4_secure << "\n";
  std::cout << "\tr4_additional_ranges = " << r4_additional_ranges << "\n";
  std::cout << "\tr4_latency = " << r4_latency << "\n";
  std::cout << "\td4_priority = " << d4_priority << "\n";
  std::cout << "\td4_vmap = " << d4_vmap << "\n";
  std::cout << "\tr5_base_address = " << r5_base_address << "\n";
  std::cout << "\tr5_size = " << r5_size << "\n";
  std::cout << "\tr5_subtract_base_address = " << r5_subtract_base_address << "\n";
  std::cout << "\tr5_secure = " << r5_secure << "\n";
  std::cout << "\tr5_additional_ranges = " << r5_additional_ranges << "\n";
  std::cout << "\tr5_latency = " << r5_latency << "\n";
  std::cout << "\td5_priority = " << d5_priority << "\n";
  std::cout << "\td5_vmap = " << d5_vmap << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/


#include <iostream>





eth_base1_pv::eth_base1_pv(sc_module_name module_name) :
  eth_pv_base(module_name) {
  dbg_port.bind(m_dbg_port_fw_process);
  m_dbg_port_fw_process.register_b_transport(this, &eth_base1_pv::dbg_port_callback);
  m_dbg_port_fw_process.register_transport_dbg(this, &eth_base1_pv::dbg_port_callback_dbg);
  m_dbg_port_fw_process.register_get_direct_mem_ptr(this, &eth_base1_pv::dbg_port_get_direct_memory_ptr_callback);

  m_model = dynamic_cast<PapoulisBusBaseModel *>(getSystemCBaseModel());
  if (m_model) {
    decoder = m_model->get_decoder();
 
  } else {
    decoder = new esl::sc_sim::user_model::Decoder(6, 12, write_broadcast);
    decoder->registerSlavePort(0, this->r0_base_address, this->r0_size, this->r0_subtract_base_address);
    decoder->registerSlavePort(2, this->r1_base_address, this->r1_size, this->r1_subtract_base_address);
    decoder->registerSlavePort(4, this->r2_base_address, this->r2_size, this->r2_subtract_base_address);
    decoder->registerSlavePort(6, this->r3_base_address, this->r3_size, this->r3_subtract_base_address);
    decoder->registerSlavePort(8, this->r4_base_address, this->r4_size, this->r4_subtract_base_address);
    decoder->registerSlavePort(10, this->r5_base_address, this->r5_size, this->r5_subtract_base_address);
    decoder->parseVmapString(1, this->d0_vmap, "d0_vmap");
    decoder->parseVmapString(3, this->d1_vmap, "d1_vmap");
    decoder->parseVmapString(5, this->d2_vmap, "d2_vmap");
    decoder->parseVmapString(7, this->d3_vmap, "d3_vmap");
    decoder->parseVmapString(9, this->d4_vmap, "d4_vmap");
    decoder->parseVmapString(11, this->d5_vmap, "d5_vmap");
  }
  
  m_port_count = 12;
  m_layers_count = m_model->get_arbiter()->get_layers_count();
  m_is_multi_channel = 0;
  m_bus_scheduler = new esl::sc_sim::BusScheduler(m_port_count, m_layers_count, m_is_multi_channel);
  m_apply_policies = false;
  m_in_loop = false;
  const char* policy_modeling = "lt_policy_modeling";
  
  mb::sysc::add_parameter_listener(this->name(), policy_modeling, this);
  if (mb::sysc::sdParameterExists(policy_modeling)) {
    if (!strcasecmp(mb::sysc::sdGetParameterAsConstString(policy_modeling), "dynamic")) {
      m_apply_policies = true;
    }
  }
}

eth_base1_pv::~eth_base1_pv()
{
  delete m_bus_scheduler;
}
void eth_base1_pv::parameter_changed(const std::string& parameter,
                                               const std::string& old_value,
                                             const std::string& new_value) {
  if (!strcasecmp(new_value.c_str(), "dynamic")) {
    m_apply_policies = true;
  }
  else {
    m_apply_policies = false;
  }
}



void eth_base1_pv::d0_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 1, false, t);
  
}

unsigned eth_base1_pv::d0_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 1, true, t);

}

bool eth_base1_pv::d0_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->r0_subtract_base_address) {
      offset = this->r0_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r0_size);
    if (this->r1_subtract_base_address) {
      offset = this->r1_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r1_size);
    if (this->r2_subtract_base_address) {
      offset = this->r2_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r2_size);
    if (this->r3_subtract_base_address) {
      offset = this->r3_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r3_size);
    if (this->r4_subtract_base_address) {
      offset = this->r4_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r4_size);
    if (this->r5_subtract_base_address) {
      offset = this->r5_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r5_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(1, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(1), 1, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(1), 1, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(1), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 1)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void eth_base1_pv::d1_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 3, false, t);
  
}

unsigned eth_base1_pv::d1_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 3, true, t);

}

bool eth_base1_pv::d1_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->r0_subtract_base_address) {
      offset = this->r0_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r0_size);
    if (this->r1_subtract_base_address) {
      offset = this->r1_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r1_size);
    if (this->r2_subtract_base_address) {
      offset = this->r2_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r2_size);
    if (this->r3_subtract_base_address) {
      offset = this->r3_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r3_size);
    if (this->r4_subtract_base_address) {
      offset = this->r4_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r4_size);
    if (this->r5_subtract_base_address) {
      offset = this->r5_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r5_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(3, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), 3, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), 3, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 3)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void eth_base1_pv::d2_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 5, false, t);
  
}

unsigned eth_base1_pv::d2_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 5, true, t);

}

bool eth_base1_pv::d2_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->r0_subtract_base_address) {
      offset = this->r0_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r0_size);
    if (this->r1_subtract_base_address) {
      offset = this->r1_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r1_size);
    if (this->r2_subtract_base_address) {
      offset = this->r2_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r2_size);
    if (this->r3_subtract_base_address) {
      offset = this->r3_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r3_size);
    if (this->r4_subtract_base_address) {
      offset = this->r4_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r4_size);
    if (this->r5_subtract_base_address) {
      offset = this->r5_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r5_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(5, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(5), 5, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(5), 5, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(5), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 5)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void eth_base1_pv::d3_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 7, false, t);
  
}

unsigned eth_base1_pv::d3_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 7, true, t);

}

bool eth_base1_pv::d3_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->r0_subtract_base_address) {
      offset = this->r0_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r0_size);
    if (this->r1_subtract_base_address) {
      offset = this->r1_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r1_size);
    if (this->r2_subtract_base_address) {
      offset = this->r2_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r2_size);
    if (this->r3_subtract_base_address) {
      offset = this->r3_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r3_size);
    if (this->r4_subtract_base_address) {
      offset = this->r4_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r4_size);
    if (this->r5_subtract_base_address) {
      offset = this->r5_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r5_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(7, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(7), 7, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(7), 7, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(7), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 7)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void eth_base1_pv::d4_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 9, false, t);
  
}

unsigned eth_base1_pv::d4_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 9, true, t);

}

bool eth_base1_pv::d4_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->r0_subtract_base_address) {
      offset = this->r0_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r0_size);
    if (this->r1_subtract_base_address) {
      offset = this->r1_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r1_size);
    if (this->r2_subtract_base_address) {
      offset = this->r2_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r2_size);
    if (this->r3_subtract_base_address) {
      offset = this->r3_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r3_size);
    if (this->r4_subtract_base_address) {
      offset = this->r4_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r4_size);
    if (this->r5_subtract_base_address) {
      offset = this->r5_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r5_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(9, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(9), 9, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(9), 9, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(9), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 9)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void eth_base1_pv::d5_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 11, false, t);
  
}

unsigned eth_base1_pv::d5_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 11, true, t);

}

bool eth_base1_pv::d5_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->r0_subtract_base_address) {
      offset = this->r0_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r0_size);
    if (this->r1_subtract_base_address) {
      offset = this->r1_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r1_size);
    if (this->r2_subtract_base_address) {
      offset = this->r2_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r2_size);
    if (this->r3_subtract_base_address) {
      offset = this->r3_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r3_size);
    if (this->r4_subtract_base_address) {
      offset = this->r4_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r4_size);
    if (this->r5_subtract_base_address) {
      offset = this->r5_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->r5_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(11, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(11), 11, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(11), 11, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(11), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 11)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void eth_base1_pv::dbg_port_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, (unsigned) (-1), false, t);
}

unsigned eth_base1_pv::dbg_port_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, (unsigned) (-1), true, t);
}

bool eth_base1_pv::dbg_port_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {
  sc_dt::uint64 virtualAddress = trans.get_address();
  std::vector<long> slavePortIndexArray;
  decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, 32, name(), "dbg_port");
  if (slavePortIndexArray.size() == 0) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
  long slavePortIndex = slavePortIndexArray[0];
  

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);
  
  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);
  return returnStatus;
}

void eth_base1_pv::clip_the_range(sc_dt::uint64 address,
                                            sc_dt::uint64 &dmiStartAddress,
                                            sc_dt::uint64 &dmiEndAddress,
                                            unsigned char* &dmiPtr,
                                            long slavePortIndex,
                                            signed long long offset) {
  sc_dt::uint64 slaveStartAddress = 0;
  sc_dt::uint64 slaveEndAddress = 0;
  bool subtractBaseAddress = true;
  decoder->getSlaveRangeByAddress(slavePortIndex, address, slaveStartAddress, slaveEndAddress, subtractBaseAddress);
  if (subtractBaseAddress) {
    
    sc_dt::uint64 translatedEndAddress = slaveEndAddress - slaveStartAddress;
    if (dmiEndAddress > translatedEndAddress)
      dmiEndAddress = translatedEndAddress;
    
    dmiStartAddress += (slaveStartAddress);
    dmiEndAddress += (slaveStartAddress);
  } else {
    if (slaveStartAddress > dmiStartAddress) {
      if (slaveStartAddress < dmiEndAddress) {
        dmiPtr += slaveStartAddress - dmiStartAddress;
        dmiStartAddress = slaveStartAddress;
      }
    }
    if (dmiEndAddress > slaveEndAddress) {
      if (slaveEndAddress > dmiStartAddress)
        dmiEndAddress = slaveEndAddress;
    }
  }
  // add the offset if from vmap parameter
  
  dmiStartAddress += (offset);
  dmiEndAddress += (offset);
}

void eth_base1_pv::invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  if (m_in_loop)
    return;
  m_in_loop = true;
  config::uint64 startAddress;
  config::uint64 endAddress;
  bool substractBaseAddress;  
  decoder->getSlaveRange(master_index, startAddress, endAddress, substractBaseAddress);
  sc_dt::uint64 current_start_range = start_range;
  sc_dt::uint64 current_end_range = end_range;
  unsigned char* dmi_ptr = 0;
  clip_the_range(startAddress, current_start_range, current_end_range, dmi_ptr, master_index, 0);
  sc_dt::uint64 original_address = 0;
original_address = decoder->getOriginalAddress(d0_idx, current_start_range);
  invalidate_direct_mem_ptr(d0_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(d1_idx, current_start_range);
  invalidate_direct_mem_ptr(d1_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(d2_idx, current_start_range);
  invalidate_direct_mem_ptr(d2_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(d3_idx, current_start_range);
  invalidate_direct_mem_ptr(d3_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(d4_idx, current_start_range);
  invalidate_direct_mem_ptr(d4_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(d5_idx, current_start_range);
  invalidate_direct_mem_ptr(d5_idx, original_address, original_address + current_end_range - current_start_range);
  m_in_loop = false;
}


void eth_base1_pv::r0_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(r0_idx, start_range, end_range);
  }
void eth_base1_pv::r1_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(r1_idx, start_range, end_range);
  }
void eth_base1_pv::r2_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(r2_idx, start_range, end_range);
  }
void eth_base1_pv::r3_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(r3_idx, start_range, end_range);
  }
void eth_base1_pv::r4_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(r4_idx, start_range, end_range);
  }
void eth_base1_pv::r5_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(r5_idx, start_range, end_range);
  }

void eth_base1_pv::invalidate_direct_mem_ptr(unsigned target_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  switch(target_index) {
  case d0_idx :
    d0->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case d1_idx :
    d1->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case d2_idx :
    d2->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case d3_idx :
    d3->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case d4_idx :
    d4->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case d5_idx :
    d5->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  }
}

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

#include "eth_model.h"

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;

void eth_t_base::createDecoder(void* userRunningModel) {
  long* portLayers = 0;
  long* readAddressLayers = 0;
  long* writeAddressLayers = 0;
  long* readDataLayers = 0;
  long* writeDataLayers = 0;
  long** mastersVmap = 0;
  if (isMultiChannel && layers && *layers == 0)
    Papoulis_ParseLayersFile(userRunningModel,
                             "d0: r0, r1, r2, r3, r4, r5; d1: r0, r1, r2, r3, r4, r5; d2: r0, r1, r2, r3, r4, r5; d3: r0, r1, r2, r3, r4, r5; d4: r0, r1, r2, r3, r4, r5; d5: r0, r1, r2, r3, r4, r5; ",
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);
    
  else
    Papoulis_ParseLayersFile(userRunningModel,
                             layers,
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);

  m_decoder = new esl::sc_sim::user_model::Decoder(6, mastersVmap, port_count, write_broadcast);
  if (!m_arbiter)
    m_arbiter = new esl::sc_sim::user_model::Arbiter(new esl::sc_sim::ArbiterScheme());
  m_arbiter->updateTables(port_count);
  m_arbiter->setDecoder(m_decoder);

  unsigned masterIndex = 0;
  for (unsigned u = 0; u < get_port_count(); u++)
    if (is_master(u)) {
      masterIndex = u;
      break;
    }

  m_decoder->insertPortName("r0");
  m_decoder->insertPortName("d0");
  m_decoder->insertPortName("r1");
  m_decoder->insertPortName("d1");
  m_decoder->insertPortName("r2");
  m_decoder->insertPortName("d2");
  m_decoder->insertPortName("r3");
  m_decoder->insertPortName("d3");
  m_decoder->insertPortName("r4");
  m_decoder->insertPortName("d4");
  m_decoder->insertPortName("r5");
  m_decoder->insertPortName("d5");
  
  std::vector<esl::sc_sim::SystemCChannel*>* channels = getReadAndWriteChannels(masterIndex);
  if (channels->size() == 1) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_IGNORE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  } else if (channels->size() == 2) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_READ_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
    channel = (*channels)[1];
    protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_WRITE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  }

  if(isMultiChannel)
    m_arbiter->setMultiChannel();
  unsigned* pendings = new unsigned[port_count];
  pendings[r0] = Papoulis_GetPending((void*)getUserRunningModel(), r0);
  pendings[d0] = Papoulis_GetPending((void*)getUserRunningModel(), d0);
  pendings[r1] = Papoulis_GetPending((void*)getUserRunningModel(), r1);
  pendings[d1] = Papoulis_GetPending((void*)getUserRunningModel(), d1);
  pendings[r2] = Papoulis_GetPending((void*)getUserRunningModel(), r2);
  pendings[d2] = Papoulis_GetPending((void*)getUserRunningModel(), d2);
  pendings[r3] = Papoulis_GetPending((void*)getUserRunningModel(), r3);
  pendings[d3] = Papoulis_GetPending((void*)getUserRunningModel(), d3);
  pendings[r4] = Papoulis_GetPending((void*)getUserRunningModel(), r4);
  pendings[d4] = Papoulis_GetPending((void*)getUserRunningModel(), d4);
  pendings[r5] = Papoulis_GetPending((void*)getUserRunningModel(), r5);
  pendings[d5] = Papoulis_GetPending((void*)getUserRunningModel(), d5);
  m_arbiter->setPendings(pendings);
  sc_dt::uint64 base_address = 0;
  if (r0_base_address == 0xffffffff && 
      sizeof(r0_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = r0_base_address;
  m_decoder->registerSlavePort(r0,
                               base_address,
                               r0_size,
                               r0_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(r0,
                                            "r0",
                                            r0_additional_ranges,
                                            r0_subtract_base_address);
  m_decoder->setSecure(r0, r0_secure, config::uint32_max);

  if (r1_base_address == 0xffffffff && 
      sizeof(r1_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = r1_base_address;
  m_decoder->registerSlavePort(r1,
                               base_address,
                               r1_size,
                               r1_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(r1,
                                            "r1",
                                            r1_additional_ranges,
                                            r1_subtract_base_address);
  m_decoder->setSecure(r1, r1_secure, config::uint32_max);

  if (r2_base_address == 0xffffffff && 
      sizeof(r2_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = r2_base_address;
  m_decoder->registerSlavePort(r2,
                               base_address,
                               r2_size,
                               r2_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(r2,
                                            "r2",
                                            r2_additional_ranges,
                                            r2_subtract_base_address);
  m_decoder->setSecure(r2, r2_secure, config::uint32_max);

  if (r3_base_address == 0xffffffff && 
      sizeof(r3_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = r3_base_address;
  m_decoder->registerSlavePort(r3,
                               base_address,
                               r3_size,
                               r3_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(r3,
                                            "r3",
                                            r3_additional_ranges,
                                            r3_subtract_base_address);
  m_decoder->setSecure(r3, r3_secure, config::uint32_max);

  if (r4_base_address == 0xffffffff && 
      sizeof(r4_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = r4_base_address;
  m_decoder->registerSlavePort(r4,
                               base_address,
                               r4_size,
                               r4_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(r4,
                                            "r4",
                                            r4_additional_ranges,
                                            r4_subtract_base_address);
  m_decoder->setSecure(r4, r4_secure, config::uint32_max);

  if (r5_base_address == 0xffffffff && 
      sizeof(r5_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = r5_base_address;
  m_decoder->registerSlavePort(r5,
                               base_address,
                               r5_size,
                               r5_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(r5,
                                            "r5",
                                            r5_additional_ranges,
                                            r5_subtract_base_address);
  m_decoder->setSecure(r5, r5_secure, config::uint32_max);

  m_decoder->registerPortPriorityAndData(d0, d0_priority, (void*)0);
  m_decoder->parseVmapString(d0, d0_vmap, "d0_vmap");
  m_decoder->registerPortPriorityAndData(d1, d1_priority, (void*)0);
  m_decoder->parseVmapString(d1, d1_vmap, "d1_vmap");
  m_decoder->registerPortPriorityAndData(d2, d2_priority, (void*)0);
  m_decoder->parseVmapString(d2, d2_vmap, "d2_vmap");
  m_decoder->registerPortPriorityAndData(d3, d3_priority, (void*)0);
  m_decoder->parseVmapString(d3, d3_vmap, "d3_vmap");
  m_decoder->registerPortPriorityAndData(d4, d4_priority, (void*)0);
  m_decoder->parseVmapString(d4, d4_vmap, "d4_vmap");
  m_decoder->registerPortPriorityAndData(d5, d5_priority, (void*)0);
  m_decoder->parseVmapString(d5, d5_vmap, "d5_vmap");
  m_decoder->checkConsistency(name());
  long portCount = 6 + 6;
  m_arbiter->generateLayerTable(portCount, portLayers, readAddressLayers, writeAddressLayers, readDataLayers, writeDataLayers);
}

void eth_t_base::schedule_generic_READ
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long ADDR, long* rDATA, long PRIORITY, long BURST, long SIZE, long STATUS) {
  scheduleGenericTransaction(portIndex,
                             0,
                             ADDR,
                             (unsigned char*)rDATA,
                             transactionSize,
                             SIZE,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}
void eth_t_base::schedule_generic_WRITE
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long ADDR, long* wDATA, long PRIORITY, long BURST, long SIZE, long STATUS) {
  scheduleGenericTransaction(portIndex,
                             1,
                             ADDR,
                             (unsigned char*)wDATA,
                             transactionSize,
                             SIZE,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

eth_t_base::eth_t_base(sc_module_name& module_name, long simulation,
                                           esl::sc_sim::user_model::Arbiter* arbiter) :
  papoulis::PapoulisBusBaseModel(module_name, arbiter, 0, 1),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(generic_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(layers, ""),
  SD_INITIALIZE_PARAMETER(slave_sets, ""),
  SD_INITIALIZE_PARAMETER(write_broadcast, 1),
  SD_INITIALIZE_PARAMETER(r0_base_address, 0),
  SD_INITIALIZE_PARAMETER(r0_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER(r0_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(r0_secure, 0),
  SD_INITIALIZE_PARAMETER(r0_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(r0_latency, 0),
  SD_INITIALIZE_PARAMETER(d0_priority, 0),
  SD_INITIALIZE_PARAMETER(d0_vmap, ""),
  SD_INITIALIZE_PARAMETER(r1_base_address, 0),
  SD_INITIALIZE_PARAMETER(r1_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER(r1_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(r1_secure, 0),
  SD_INITIALIZE_PARAMETER(r1_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(r1_latency, 0),
  SD_INITIALIZE_PARAMETER(d1_priority, 0),
  SD_INITIALIZE_PARAMETER(d1_vmap, ""),
  SD_INITIALIZE_PARAMETER(r2_base_address, 0),
  SD_INITIALIZE_PARAMETER(r2_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER(r2_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(r2_secure, 0),
  SD_INITIALIZE_PARAMETER(r2_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(r2_latency, 0),
  SD_INITIALIZE_PARAMETER(d2_priority, 0),
  SD_INITIALIZE_PARAMETER(d2_vmap, ""),
  SD_INITIALIZE_PARAMETER(r3_base_address, 0),
  SD_INITIALIZE_PARAMETER(r3_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER(r3_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(r3_secure, 0),
  SD_INITIALIZE_PARAMETER(r3_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(r3_latency, 0),
  SD_INITIALIZE_PARAMETER(d3_priority, 0),
  SD_INITIALIZE_PARAMETER(d3_vmap, ""),
  SD_INITIALIZE_PARAMETER(r4_base_address, 0),
  SD_INITIALIZE_PARAMETER(r4_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER(r4_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(r4_secure, 0),
  SD_INITIALIZE_PARAMETER(r4_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(r4_latency, 0),
  SD_INITIALIZE_PARAMETER(d4_priority, 0),
  SD_INITIALIZE_PARAMETER(d4_vmap, ""),
  SD_INITIALIZE_PARAMETER(r5_base_address, 0),
  SD_INITIALIZE_PARAMETER(r5_size, 0xFFFFFFFF),
  SD_INITIALIZE_PARAMETER(r5_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(r5_secure, 0),
  SD_INITIALIZE_PARAMETER(r5_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(r5_latency, 0),
  SD_INITIALIZE_PARAMETER(d5_priority, 0),
  SD_INITIALIZE_PARAMETER(d5_vmap, ""),
        m_simulation(simulation), m_current_request(0)
{
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  fix_clock_parameter(generic_clock, "generic_clock");
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[r0].port_name = "r0";
  port_descriptions[r0].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[r0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[r0].is_master_port = 1;
  port_descriptions[r0].is_signal_port = 0;
  port_descriptions[r0].port_width = ((32 + 7) >> 3);
  port_descriptions[r0].port_width_in_bits = 32;
  port_descriptions[r0].protocol_name = "generic";
  port_descriptions[r0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[r0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[r0].ipxactBusDef.name = "generic";
  port_descriptions[r0].ipxactBusDef.version = "1.0"; 
  port_descriptions[r0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[r0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[r0].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[r0].ipxactAbstrDef.version = "1.0";
  port_descriptions[r0].port_must_bind = 0;
  port_descriptions[r0].params_count = 6;
  port_descriptions[r0].clock = generic_clock;
  port_descriptions[r0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[r0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[d0].port_name = "d0";
  port_descriptions[d0].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[d0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[d0].is_master_port = 0;
  port_descriptions[d0].is_signal_port = 0;
  port_descriptions[d0].port_width = ((32 + 7) >> 3);
  port_descriptions[d0].port_width_in_bits = 32;
  port_descriptions[d0].protocol_name = "generic";
  port_descriptions[d0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[d0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[d0].ipxactBusDef.name = "generic";
  port_descriptions[d0].ipxactBusDef.version = "1.0"; 
  port_descriptions[d0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[d0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[d0].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[d0].ipxactAbstrDef.version = "1.0";
  port_descriptions[d0].port_must_bind = 0;
  port_descriptions[d0].params_count = 6;
  port_descriptions[d0].clock = generic_clock;
  port_descriptions[d0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[d0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[r1].port_name = "r1";
  port_descriptions[r1].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[r1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[r1].is_master_port = 1;
  port_descriptions[r1].is_signal_port = 0;
  port_descriptions[r1].port_width = ((32 + 7) >> 3);
  port_descriptions[r1].port_width_in_bits = 32;
  port_descriptions[r1].protocol_name = "generic";
  port_descriptions[r1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[r1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[r1].ipxactBusDef.name = "generic";
  port_descriptions[r1].ipxactBusDef.version = "1.0"; 
  port_descriptions[r1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[r1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[r1].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[r1].ipxactAbstrDef.version = "1.0";
  port_descriptions[r1].port_must_bind = 0;
  port_descriptions[r1].params_count = 6;
  port_descriptions[r1].clock = generic_clock;
  port_descriptions[r1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[r1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[d1].port_name = "d1";
  port_descriptions[d1].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[d1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[d1].is_master_port = 0;
  port_descriptions[d1].is_signal_port = 0;
  port_descriptions[d1].port_width = ((32 + 7) >> 3);
  port_descriptions[d1].port_width_in_bits = 32;
  port_descriptions[d1].protocol_name = "generic";
  port_descriptions[d1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[d1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[d1].ipxactBusDef.name = "generic";
  port_descriptions[d1].ipxactBusDef.version = "1.0"; 
  port_descriptions[d1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[d1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[d1].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[d1].ipxactAbstrDef.version = "1.0";
  port_descriptions[d1].port_must_bind = 0;
  port_descriptions[d1].params_count = 6;
  port_descriptions[d1].clock = generic_clock;
  port_descriptions[d1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[d1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[r2].port_name = "r2";
  port_descriptions[r2].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[r2].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[r2].is_master_port = 1;
  port_descriptions[r2].is_signal_port = 0;
  port_descriptions[r2].port_width = ((32 + 7) >> 3);
  port_descriptions[r2].port_width_in_bits = 32;
  port_descriptions[r2].protocol_name = "generic";
  port_descriptions[r2].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[r2].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[r2].ipxactBusDef.name = "generic";
  port_descriptions[r2].ipxactBusDef.version = "1.0"; 
  port_descriptions[r2].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[r2].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[r2].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[r2].ipxactAbstrDef.version = "1.0";
  port_descriptions[r2].port_must_bind = 0;
  port_descriptions[r2].params_count = 6;
  port_descriptions[r2].clock = generic_clock;
  port_descriptions[r2].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[r2].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[d2].port_name = "d2";
  port_descriptions[d2].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[d2].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[d2].is_master_port = 0;
  port_descriptions[d2].is_signal_port = 0;
  port_descriptions[d2].port_width = ((32 + 7) >> 3);
  port_descriptions[d2].port_width_in_bits = 32;
  port_descriptions[d2].protocol_name = "generic";
  port_descriptions[d2].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[d2].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[d2].ipxactBusDef.name = "generic";
  port_descriptions[d2].ipxactBusDef.version = "1.0"; 
  port_descriptions[d2].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[d2].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[d2].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[d2].ipxactAbstrDef.version = "1.0";
  port_descriptions[d2].port_must_bind = 0;
  port_descriptions[d2].params_count = 6;
  port_descriptions[d2].clock = generic_clock;
  port_descriptions[d2].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[d2].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[r3].port_name = "r3";
  port_descriptions[r3].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[r3].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[r3].is_master_port = 1;
  port_descriptions[r3].is_signal_port = 0;
  port_descriptions[r3].port_width = ((32 + 7) >> 3);
  port_descriptions[r3].port_width_in_bits = 32;
  port_descriptions[r3].protocol_name = "generic";
  port_descriptions[r3].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[r3].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[r3].ipxactBusDef.name = "generic";
  port_descriptions[r3].ipxactBusDef.version = "1.0"; 
  port_descriptions[r3].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[r3].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[r3].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[r3].ipxactAbstrDef.version = "1.0";
  port_descriptions[r3].port_must_bind = 0;
  port_descriptions[r3].params_count = 6;
  port_descriptions[r3].clock = generic_clock;
  port_descriptions[r3].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[r3].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[d3].port_name = "d3";
  port_descriptions[d3].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[d3].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[d3].is_master_port = 0;
  port_descriptions[d3].is_signal_port = 0;
  port_descriptions[d3].port_width = ((32 + 7) >> 3);
  port_descriptions[d3].port_width_in_bits = 32;
  port_descriptions[d3].protocol_name = "generic";
  port_descriptions[d3].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[d3].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[d3].ipxactBusDef.name = "generic";
  port_descriptions[d3].ipxactBusDef.version = "1.0"; 
  port_descriptions[d3].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[d3].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[d3].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[d3].ipxactAbstrDef.version = "1.0";
  port_descriptions[d3].port_must_bind = 0;
  port_descriptions[d3].params_count = 6;
  port_descriptions[d3].clock = generic_clock;
  port_descriptions[d3].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[d3].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[r4].port_name = "r4";
  port_descriptions[r4].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[r4].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[r4].is_master_port = 1;
  port_descriptions[r4].is_signal_port = 0;
  port_descriptions[r4].port_width = ((32 + 7) >> 3);
  port_descriptions[r4].port_width_in_bits = 32;
  port_descriptions[r4].protocol_name = "generic";
  port_descriptions[r4].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[r4].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[r4].ipxactBusDef.name = "generic";
  port_descriptions[r4].ipxactBusDef.version = "1.0"; 
  port_descriptions[r4].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[r4].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[r4].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[r4].ipxactAbstrDef.version = "1.0";
  port_descriptions[r4].port_must_bind = 0;
  port_descriptions[r4].params_count = 6;
  port_descriptions[r4].clock = generic_clock;
  port_descriptions[r4].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[r4].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[d4].port_name = "d4";
  port_descriptions[d4].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[d4].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[d4].is_master_port = 0;
  port_descriptions[d4].is_signal_port = 0;
  port_descriptions[d4].port_width = ((32 + 7) >> 3);
  port_descriptions[d4].port_width_in_bits = 32;
  port_descriptions[d4].protocol_name = "generic";
  port_descriptions[d4].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[d4].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[d4].ipxactBusDef.name = "generic";
  port_descriptions[d4].ipxactBusDef.version = "1.0"; 
  port_descriptions[d4].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[d4].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[d4].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[d4].ipxactAbstrDef.version = "1.0";
  port_descriptions[d4].port_must_bind = 0;
  port_descriptions[d4].params_count = 6;
  port_descriptions[d4].clock = generic_clock;
  port_descriptions[d4].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[d4].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[r5].port_name = "r5";
  port_descriptions[r5].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[r5].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[r5].is_master_port = 1;
  port_descriptions[r5].is_signal_port = 0;
  port_descriptions[r5].port_width = ((32 + 7) >> 3);
  port_descriptions[r5].port_width_in_bits = 32;
  port_descriptions[r5].protocol_name = "generic";
  port_descriptions[r5].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[r5].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[r5].ipxactBusDef.name = "generic";
  port_descriptions[r5].ipxactBusDef.version = "1.0"; 
  port_descriptions[r5].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[r5].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[r5].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[r5].ipxactAbstrDef.version = "1.0";
  port_descriptions[r5].port_must_bind = 0;
  port_descriptions[r5].params_count = 6;
  port_descriptions[r5].clock = generic_clock;
  port_descriptions[r5].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[r5].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[d5].port_name = "d5";
  port_descriptions[d5].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[d5].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[d5].is_master_port = 0;
  port_descriptions[d5].is_signal_port = 0;
  port_descriptions[d5].port_width = ((32 + 7) >> 3);
  port_descriptions[d5].port_width_in_bits = 32;
  port_descriptions[d5].protocol_name = "generic";
  port_descriptions[d5].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[d5].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[d5].ipxactBusDef.name = "generic";
  port_descriptions[d5].ipxactBusDef.version = "1.0"; 
  port_descriptions[d5].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[d5].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[d5].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[d5].ipxactAbstrDef.version = "1.0";
  port_descriptions[d5].port_must_bind = 0;
  port_descriptions[d5].params_count = 6;
  port_descriptions[d5].clock = generic_clock;
  port_descriptions[d5].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[d5].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  port_descriptions[r0].default_read_transaction_name = "READ";
  port_descriptions[d0].default_read_transaction_name = "READ";
  port_descriptions[r1].default_read_transaction_name = "READ";
  port_descriptions[d1].default_read_transaction_name = "READ";
  port_descriptions[r2].default_read_transaction_name = "READ";
  port_descriptions[d2].default_read_transaction_name = "READ";
  port_descriptions[r3].default_read_transaction_name = "READ";
  port_descriptions[d3].default_read_transaction_name = "READ";
  port_descriptions[r4].default_read_transaction_name = "READ";
  port_descriptions[d4].default_read_transaction_name = "READ";
  port_descriptions[r5].default_read_transaction_name = "READ";
  port_descriptions[d5].default_read_transaction_name = "READ";

  port_descriptions[r0].default_write_transaction_name = "WRITE";
  port_descriptions[d0].default_write_transaction_name = "WRITE";
  port_descriptions[r1].default_write_transaction_name = "WRITE";
  port_descriptions[d1].default_write_transaction_name = "WRITE";
  port_descriptions[r2].default_write_transaction_name = "WRITE";
  port_descriptions[d2].default_write_transaction_name = "WRITE";
  port_descriptions[r3].default_write_transaction_name = "WRITE";
  port_descriptions[d3].default_write_transaction_name = "WRITE";
  port_descriptions[r4].default_write_transaction_name = "WRITE";
  port_descriptions[d4].default_write_transaction_name = "WRITE";
  port_descriptions[r5].default_write_transaction_name = "WRITE";
  port_descriptions[d5].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);
  
  esl::tlm_sim::UserRunningModel* model = Papoulis_CreateUserRunningModel(name(),
                                                                          0,
                                                                          this,
                                                                          simulation,
                                                                          true,
                                                                          false);
  setUserRunningModel(model, false);
  createDecoder(model);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("generic_clock", "sc_core::sc_time", sdGetParameterAsConstString("generic_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("layers", "const char*", sdGetParameterAsConstString("layers"));
  registerParameter("slave_sets", "const char*", sdGetParameterAsConstString("slave_sets"));
  registerParameter("write_broadcast", "unsigned int", sdGetParameterAsConstString("write_broadcast"));
  registerParameter("r0_base_address", "unsigned long long", sdGetParameterAsConstString("r0_base_address"));
  registerParameter("r0_size", "unsigned long long", sdGetParameterAsConstString("r0_size"));
  registerParameter("r0_subtract_base_address", "unsigned int", sdGetParameterAsConstString("r0_subtract_base_address"));
  registerParameter("r0_secure", "unsigned int", sdGetParameterAsConstString("r0_secure"));
  registerParameter("r0_additional_ranges", "const char*", sdGetParameterAsConstString("r0_additional_ranges"));
  registerParameter("r0_latency", "unsigned int", sdGetParameterAsConstString("r0_latency"));
  registerParameter("d0_priority", "unsigned int", sdGetParameterAsConstString("d0_priority"));
  registerParameter("d0_vmap", "const char*", sdGetParameterAsConstString("d0_vmap"));
  registerParameter("r1_base_address", "unsigned long long", sdGetParameterAsConstString("r1_base_address"));
  registerParameter("r1_size", "unsigned long long", sdGetParameterAsConstString("r1_size"));
  registerParameter("r1_subtract_base_address", "unsigned int", sdGetParameterAsConstString("r1_subtract_base_address"));
  registerParameter("r1_secure", "unsigned int", sdGetParameterAsConstString("r1_secure"));
  registerParameter("r1_additional_ranges", "const char*", sdGetParameterAsConstString("r1_additional_ranges"));
  registerParameter("r1_latency", "unsigned int", sdGetParameterAsConstString("r1_latency"));
  registerParameter("d1_priority", "unsigned int", sdGetParameterAsConstString("d1_priority"));
  registerParameter("d1_vmap", "const char*", sdGetParameterAsConstString("d1_vmap"));
  registerParameter("r2_base_address", "unsigned long long", sdGetParameterAsConstString("r2_base_address"));
  registerParameter("r2_size", "unsigned long long", sdGetParameterAsConstString("r2_size"));
  registerParameter("r2_subtract_base_address", "unsigned int", sdGetParameterAsConstString("r2_subtract_base_address"));
  registerParameter("r2_secure", "unsigned int", sdGetParameterAsConstString("r2_secure"));
  registerParameter("r2_additional_ranges", "const char*", sdGetParameterAsConstString("r2_additional_ranges"));
  registerParameter("r2_latency", "unsigned int", sdGetParameterAsConstString("r2_latency"));
  registerParameter("d2_priority", "unsigned int", sdGetParameterAsConstString("d2_priority"));
  registerParameter("d2_vmap", "const char*", sdGetParameterAsConstString("d2_vmap"));
  registerParameter("r3_base_address", "unsigned long long", sdGetParameterAsConstString("r3_base_address"));
  registerParameter("r3_size", "unsigned long long", sdGetParameterAsConstString("r3_size"));
  registerParameter("r3_subtract_base_address", "unsigned int", sdGetParameterAsConstString("r3_subtract_base_address"));
  registerParameter("r3_secure", "unsigned int", sdGetParameterAsConstString("r3_secure"));
  registerParameter("r3_additional_ranges", "const char*", sdGetParameterAsConstString("r3_additional_ranges"));
  registerParameter("r3_latency", "unsigned int", sdGetParameterAsConstString("r3_latency"));
  registerParameter("d3_priority", "unsigned int", sdGetParameterAsConstString("d3_priority"));
  registerParameter("d3_vmap", "const char*", sdGetParameterAsConstString("d3_vmap"));
  registerParameter("r4_base_address", "unsigned long long", sdGetParameterAsConstString("r4_base_address"));
  registerParameter("r4_size", "unsigned long long", sdGetParameterAsConstString("r4_size"));
  registerParameter("r4_subtract_base_address", "unsigned int", sdGetParameterAsConstString("r4_subtract_base_address"));
  registerParameter("r4_secure", "unsigned int", sdGetParameterAsConstString("r4_secure"));
  registerParameter("r4_additional_ranges", "const char*", sdGetParameterAsConstString("r4_additional_ranges"));
  registerParameter("r4_latency", "unsigned int", sdGetParameterAsConstString("r4_latency"));
  registerParameter("d4_priority", "unsigned int", sdGetParameterAsConstString("d4_priority"));
  registerParameter("d4_vmap", "const char*", sdGetParameterAsConstString("d4_vmap"));
  registerParameter("r5_base_address", "unsigned long long", sdGetParameterAsConstString("r5_base_address"));
  registerParameter("r5_size", "unsigned long long", sdGetParameterAsConstString("r5_size"));
  registerParameter("r5_subtract_base_address", "unsigned int", sdGetParameterAsConstString("r5_subtract_base_address"));
  registerParameter("r5_secure", "unsigned int", sdGetParameterAsConstString("r5_secure"));
  registerParameter("r5_additional_ranges", "const char*", sdGetParameterAsConstString("r5_additional_ranges"));
  registerParameter("r5_latency", "unsigned int", sdGetParameterAsConstString("r5_latency"));
  registerParameter("d5_priority", "unsigned int", sdGetParameterAsConstString("d5_priority"));
  registerParameter("d5_vmap", "const char*", sdGetParameterAsConstString("d5_vmap"));
  

  delay_policy* delay_policy_handle = 0;

  delay_policy_handle = new delay_policy(model,
                                         "d0",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "d1",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "d2",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "d3",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "d4",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "d5",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  unsigned pipeline_policy_index = 0;
  pipeline_policy* pipeline_policy_handle = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r0";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r0_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r1";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r1_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r2";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r2_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r3";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r3_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r4";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r4_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r5";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r5_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r0";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r0_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r1";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r1_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r2";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r2_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r3";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r3_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r4";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r4_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r5";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r5_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d2";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r0";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r0_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d2";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r1";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r1_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d2";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r2";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r2_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d2";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r3";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r3_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d2";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r4";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r4_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d2";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r5";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r5_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d3";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r0";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r0_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d3";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r1";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r1_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d3";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r2";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r2_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d3";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r3";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r3_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d3";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r4";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r4_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d3";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r5";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r5_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d4";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r0";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r0_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d4";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r1";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r1_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d4";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r2";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r2_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d4";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r3";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r3_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d4";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r4";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r4_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d4";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r5";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r5_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d5";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r0";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r0_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d5";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r1";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r1_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d5";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r2";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r2_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d5";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r3";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r3_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d5";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r4";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r4_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "d5";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "r5";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(r5_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  set_user_pipeline_policies(user_pipeline_policy_count, user_pipeline_policy_descriptions);
  
  constant_global_power_policy* p = new constant_global_power_policy(model);
  
  
  
  set_global_power_policy(p);
}

void eth_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;

  if (handle == m_pipeline_vector[0]) {
    handle->setLatency(r0_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[1]) {
    handle->setLatency(r1_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[2]) {
    handle->setLatency(r2_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[3]) {
    handle->setLatency(r3_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[4]) {
    handle->setLatency(r4_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[5]) {
    handle->setLatency(r5_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[6]) {
    handle->setLatency(r0_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[7]) {
    handle->setLatency(r1_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[8]) {
    handle->setLatency(r2_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[9]) {
    handle->setLatency(r3_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[10]) {
    handle->setLatency(r4_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[11]) {
    handle->setLatency(r5_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[12]) {
    handle->setLatency(r0_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[13]) {
    handle->setLatency(r1_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[14]) {
    handle->setLatency(r2_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[15]) {
    handle->setLatency(r3_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[16]) {
    handle->setLatency(r4_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[17]) {
    handle->setLatency(r5_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[18]) {
    handle->setLatency(r0_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[19]) {
    handle->setLatency(r1_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[20]) {
    handle->setLatency(r2_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[21]) {
    handle->setLatency(r3_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[22]) {
    handle->setLatency(r4_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[23]) {
    handle->setLatency(r5_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[24]) {
    handle->setLatency(r0_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[25]) {
    handle->setLatency(r1_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[26]) {
    handle->setLatency(r2_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[27]) {
    handle->setLatency(r3_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[28]) {
    handle->setLatency(r4_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[29]) {
    handle->setLatency(r5_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[30]) {
    handle->setLatency(r0_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[31]) {
    handle->setLatency(r1_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[32]) {
    handle->setLatency(r2_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[33]) {
    handle->setLatency(r3_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[34]) {
    handle->setLatency(r4_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[35]) {
    handle->setLatency(r5_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }

}

void eth_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[1]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[2]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[3]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[4]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[5]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
}

void eth_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}


void eth_t_base::vista_trace(bool isStart, request_type* request, long portIndex, sc_dt::uint64 startTime) {
  
  sc_dt::uint64 local_params[6];
  for (unsigned u = 0; u < 6; u++)
    local_params[u] = 0;
  
  sc_dt::uint64 address = request->get_address();
  
  local_params[0] = address;
  
  local_params[4] = get_port_width(portIndex);
  sc_dt::uint64* parameters = local_params;
  long size = request->get_data_length();
  
  bool isWrite = request->is_write();
  m_current_request = request;
  if(isStart) {
    this->print_transaction(portIndex, isWrite, true, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->accept_generic_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      } else {
        this->accept_generic_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      }
    } else {
      if (is_master(portIndex)) {
        this->accept_generic_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      } else {
        this->accept_generic_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      }
    }
  } else {
    this->print_transaction(portIndex, isWrite, false, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->end_generic_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      } else {
        this->end_generic_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      }
    } else {
      if (is_master(portIndex)) {
        this->end_generic_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      } else {
        this->end_generic_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5]);
      }
    }
  }
  m_current_request = 0;
}

request_type* eth_t_base::get_current_request() {
  return m_current_request;
}

unsigned eth_t_base::get_layer(unsigned port_index) {
  if (is_slave(port_index))
    return m_arbiter->get_slave_layer(port_index);
  return m_arbiter->get_master_layer(port_index);
}

unsigned eth_t_base::get_slave_port_index() {
  if (!m_current_request) {
    printf("ERROR: when calling get_slave_port_index in %s\n", name());
    return (unsigned)(-1);
  }
  return  m_arbiter->getMasterIndexByRequestId(m_current_request);
}

void eth_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2015     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for eth.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.2.1
//* Generated on: Aug. 12, 2016 03:01:29 PM, (user: jon)
//*>

#include "eth_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "eth_pv.h"




// Constructor

eth_pvt::eth_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    eth_pvt_param_defaults(this->name()),
    r0("r0"),
    r1("r1"),
    r2("r2"),
    r3("r3"),
    r4("r4"),
    r5("r5"),
    d0("d0"),
    d1("d1"),
    d2("d2"),
    d3("d3"),
    d4("d4"),
    d5("d5"),
    r0_entry("unvisible_r0_entry"),
    r1_entry("unvisible_r1_entry"),
    r2_entry("unvisible_r2_entry"),
    r3_entry("unvisible_r3_entry"),
    r4_entry("unvisible_r4_entry"),
    r5_entry("unvisible_r5_entry"),
    d0_entry("unvisible_d0_entry"),
    d1_entry("unvisible_d1_entry"),
    d2_entry("unvisible_d2_entry"),
    d3_entry("unvisible_d3_entry"),
    d4_entry("unvisible_d4_entry"),
    d5_entry("unvisible_d5_entry"),
    m_r0_nb_connector(*this),
    m_r1_nb_connector(*this),
    m_r2_nb_connector(*this),
    m_r3_nb_connector(*this),
    m_r4_nb_connector(*this),
    m_r5_nb_connector(*this),
    m_d0_nb_connector(*this),
    m_d1_nb_connector(*this),
    m_d2_nb_connector(*this),
    m_d3_nb_connector(*this),
    m_d4_nb_connector(*this),
    m_d5_nb_connector(*this)
    

{
  // r0 - not a vector port
  // r1 - not a vector port
  // r2 - not a vector port
  // r3 - not a vector port
  // r4 - not a vector port
  // r5 - not a vector port
  // d0 - not a vector port
  // d1 - not a vector port
  // d2 - not a vector port
  // d3 - not a vector port
  // d4 - not a vector port
  // d5 - not a vector port



  m_eth_t = eth_t_base::create_t("T", 1);
  m_eth_pv = new eth_pv("PV");
  bind();
}  


eth_pvt::eth_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time generic_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, const char* layers_init, const char* slave_sets_init, unsigned int write_broadcast_init, unsigned long long r0_base_address_init, unsigned long long r0_size_init, unsigned int r0_subtract_base_address_init, unsigned int r0_secure_init, const char* r0_additional_ranges_init, unsigned int r0_latency_init, unsigned int d0_priority_init, const char* d0_vmap_init, unsigned long long r1_base_address_init, unsigned long long r1_size_init, unsigned int r1_subtract_base_address_init, unsigned int r1_secure_init, const char* r1_additional_ranges_init, unsigned int r1_latency_init, unsigned int d1_priority_init, const char* d1_vmap_init, unsigned long long r2_base_address_init, unsigned long long r2_size_init, unsigned int r2_subtract_base_address_init, unsigned int r2_secure_init, const char* r2_additional_ranges_init, unsigned int r2_latency_init, unsigned int d2_priority_init, const char* d2_vmap_init, unsigned long long r3_base_address_init, unsigned long long r3_size_init, unsigned int r3_subtract_base_address_init, unsigned int r3_secure_init, const char* r3_additional_ranges_init, unsigned int r3_latency_init, unsigned int d3_priority_init, const char* d3_vmap_init, unsigned long long r4_base_address_init, unsigned long long r4_size_init, unsigned int r4_subtract_base_address_init, unsigned int r4_secure_init, const char* r4_additional_ranges_init, unsigned int r4_latency_init, unsigned int d4_priority_init, const char* d4_vmap_init, unsigned long long r5_base_address_init, unsigned long long r5_size_init, unsigned int r5_subtract_base_address_init, unsigned int r5_secure_init, const char* r5_additional_ranges_init, unsigned int r5_latency_init, unsigned int d5_priority_init, const char* d5_vmap_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  eth_pvt_param_defaults(this->name(), clock_init, generic_clock_init, nominal_voltage_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, layers_init, slave_sets_init, write_broadcast_init, r0_base_address_init, r0_size_init, r0_subtract_base_address_init, r0_secure_init, r0_additional_ranges_init, r0_latency_init, d0_priority_init, d0_vmap_init, r1_base_address_init, r1_size_init, r1_subtract_base_address_init, r1_secure_init, r1_additional_ranges_init, r1_latency_init, d1_priority_init, d1_vmap_init, r2_base_address_init, r2_size_init, r2_subtract_base_address_init, r2_secure_init, r2_additional_ranges_init, r2_latency_init, d2_priority_init, d2_vmap_init, r3_base_address_init, r3_size_init, r3_subtract_base_address_init, r3_secure_init, r3_additional_ranges_init, r3_latency_init, d3_priority_init, d3_vmap_init, r4_base_address_init, r4_size_init, r4_subtract_base_address_init, r4_secure_init, r4_additional_ranges_init, r4_latency_init, d4_priority_init, d4_vmap_init, r5_base_address_init, r5_size_init, r5_subtract_base_address_init, r5_secure_init, r5_additional_ranges_init, r5_latency_init, d5_priority_init, d5_vmap_init),
    r0("r0"),
    r1("r1"),
    r2("r2"),
    r3("r3"),
    r4("r4"),
    r5("r5"),
    d0("d0"),
    d1("d1"),
    d2("d2"),
    d3("d3"),
    d4("d4"),
    d5("d5"),
    r0_entry("unvisible_r0_entry"),
    r1_entry("unvisible_r1_entry"),
    r2_entry("unvisible_r2_entry"),
    r3_entry("unvisible_r3_entry"),
    r4_entry("unvisible_r4_entry"),
    r5_entry("unvisible_r5_entry"),
    d0_entry("unvisible_d0_entry"),
    d1_entry("unvisible_d1_entry"),
    d2_entry("unvisible_d2_entry"),
    d3_entry("unvisible_d3_entry"),
    d4_entry("unvisible_d4_entry"),
    d5_entry("unvisible_d5_entry"),
    m_r0_nb_connector(*this),
    m_r1_nb_connector(*this),
    m_r2_nb_connector(*this),
    m_r3_nb_connector(*this),
    m_r4_nb_connector(*this),
    m_r5_nb_connector(*this),
    m_d0_nb_connector(*this),
    m_d1_nb_connector(*this),
    m_d2_nb_connector(*this),
    m_d3_nb_connector(*this),
    m_d4_nb_connector(*this),
    m_d5_nb_connector(*this)
    
{

  // r0 - not a vector port
  // r1 - not a vector port
  // r2 - not a vector port
  // r3 - not a vector port
  // r4 - not a vector port
  // r5 - not a vector port
  // d0 - not a vector port
  // d1 - not a vector port
  // d2 - not a vector port
  // d3 - not a vector port
  // d4 - not a vector port
  // d5 - not a vector port
  


  m_eth_t = eth_t_base::create_t("T", 1);
  m_eth_pv = new eth_pv("PV");
  bind();
} 

eth_pvt::eth_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  eth_pvt_param_defaults(this->name(), change_parameters),
    r0("r0"),
    r1("r1"),
    r2("r2"),
    r3("r3"),
    r4("r4"),
    r5("r5"),
    d0("d0"),
    d1("d1"),
    d2("d2"),
    d3("d3"),
    d4("d4"),
    d5("d5"),
    r0_entry("unvisible_r0_entry"),
    r1_entry("unvisible_r1_entry"),
    r2_entry("unvisible_r2_entry"),
    r3_entry("unvisible_r3_entry"),
    r4_entry("unvisible_r4_entry"),
    r5_entry("unvisible_r5_entry"),
    d0_entry("unvisible_d0_entry"),
    d1_entry("unvisible_d1_entry"),
    d2_entry("unvisible_d2_entry"),
    d3_entry("unvisible_d3_entry"),
    d4_entry("unvisible_d4_entry"),
    d5_entry("unvisible_d5_entry"),
    m_r0_nb_connector(*this),
    m_r1_nb_connector(*this),
    m_r2_nb_connector(*this),
    m_r3_nb_connector(*this),
    m_r4_nb_connector(*this),
    m_r5_nb_connector(*this),
    m_d0_nb_connector(*this),
    m_d1_nb_connector(*this),
    m_d2_nb_connector(*this),
    m_d3_nb_connector(*this),
    m_d4_nb_connector(*this),
    m_d5_nb_connector(*this)
    
{

  // r0 - not a vector port
  // r1 - not a vector port
  // r2 - not a vector port
  // r3 - not a vector port
  // r4 - not a vector port
  // r5 - not a vector port
  // d0 - not a vector port
  // d1 - not a vector port
  // d2 - not a vector port
  // d3 - not a vector port
  // d4 - not a vector port
  // d5 - not a vector port
  


  m_eth_t = eth_t_base::create_t("T", 1);
  m_eth_pv = new eth_pv("PV");
  bind();
} 

eth_pvt::~eth_pvt() {
  remove_pending_scenes();
  delete m_eth_t; delete m_eth_pv;
}




void eth_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->r0.bind(r0_entry);
  getPV()->r1.bind(r1_entry);
  getPV()->r2.bind(r2_entry);
  getPV()->r3.bind(r3_entry);
  getPV()->r4.bind(r4_entry);
  getPV()->r5.bind(r5_entry);
  d0_entry.bind(getPV()->d0); 
  d1_entry.bind(getPV()->d1); 
  d2_entry.bind(getPV()->d2); 
  d3_entry.bind(getPV()->d3); 
  d4_entry.bind(getPV()->d4); 
  d5_entry.bind(getPV()->d5);    

  /* set callbacks on external and entry ports */ 

  d0.b_transport_cb.set(&d0_entry, &d0_entry_type::b_transport);
  d0.transport_dbg_cb.set(&d0_entry, &d0_entry_type::transport_dbg);
  d0.get_direct_mem_ptr_cb.set(&d0_entry, &d0_entry_type::get_direct_mem_ptr);
  
  d1.b_transport_cb.set(&d1_entry, &d1_entry_type::b_transport);
  d1.transport_dbg_cb.set(&d1_entry, &d1_entry_type::transport_dbg);
  d1.get_direct_mem_ptr_cb.set(&d1_entry, &d1_entry_type::get_direct_mem_ptr);
  
  d2.b_transport_cb.set(&d2_entry, &d2_entry_type::b_transport);
  d2.transport_dbg_cb.set(&d2_entry, &d2_entry_type::transport_dbg);
  d2.get_direct_mem_ptr_cb.set(&d2_entry, &d2_entry_type::get_direct_mem_ptr);
  
  d3.b_transport_cb.set(&d3_entry, &d3_entry_type::b_transport);
  d3.transport_dbg_cb.set(&d3_entry, &d3_entry_type::transport_dbg);
  d3.get_direct_mem_ptr_cb.set(&d3_entry, &d3_entry_type::get_direct_mem_ptr);
  
  d4.b_transport_cb.set(&d4_entry, &d4_entry_type::b_transport);
  d4.transport_dbg_cb.set(&d4_entry, &d4_entry_type::transport_dbg);
  d4.get_direct_mem_ptr_cb.set(&d4_entry, &d4_entry_type::get_direct_mem_ptr);
  
  d5.b_transport_cb.set(&d5_entry, &d5_entry_type::b_transport);
  d5.transport_dbg_cb.set(&d5_entry, &d5_entry_type::transport_dbg);
  d5.get_direct_mem_ptr_cb.set(&d5_entry, &d5_entry_type::get_direct_mem_ptr);
  
  r0_entry.b_transport_cb.set(this, &self_type::b_transport_outside_r0);
  r0_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_r0);
  r0_entry.get_direct_mem_ptr_cb.set(&r0, &r0_type::get_direct_mem_ptr);
  
  r1_entry.b_transport_cb.set(this, &self_type::b_transport_outside_r1);
  r1_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_r1);
  r1_entry.get_direct_mem_ptr_cb.set(&r1, &r1_type::get_direct_mem_ptr);
  
  r2_entry.b_transport_cb.set(this, &self_type::b_transport_outside_r2);
  r2_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_r2);
  r2_entry.get_direct_mem_ptr_cb.set(&r2, &r2_type::get_direct_mem_ptr);
  
  r3_entry.b_transport_cb.set(this, &self_type::b_transport_outside_r3);
  r3_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_r3);
  r3_entry.get_direct_mem_ptr_cb.set(&r3, &r3_type::get_direct_mem_ptr);
  
  r4_entry.b_transport_cb.set(this, &self_type::b_transport_outside_r4);
  r4_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_r4);
  r4_entry.get_direct_mem_ptr_cb.set(&r4, &r4_type::get_direct_mem_ptr);
  
  r5_entry.b_transport_cb.set(this, &self_type::b_transport_outside_r5);
  r5_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_r5);
  r5_entry.get_direct_mem_ptr_cb.set(&r5, &r5_type::get_direct_mem_ptr);
  
  
  /* connect t non blocking callbacks */

  r0.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_r0);
  getT()->set_port_cb(0, &m_r0_nb_connector);
  
  r1.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_r1);
  getT()->set_port_cb(2, &m_r1_nb_connector);
  
  r2.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_r2);
  getT()->set_port_cb(4, &m_r2_nb_connector);
  
  r3.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_r3);
  getT()->set_port_cb(6, &m_r3_nb_connector);
  
  r4.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_r4);
  getT()->set_port_cb(8, &m_r4_nb_connector);
  
  r5.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_r5);
  getT()->set_port_cb(10, &m_r5_nb_connector);
  
  d0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_d0);
  getT()->set_port_cb(1, &m_d0_nb_connector);
  
  d1.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_d1);
  getT()->set_port_cb(3, &m_d1_nb_connector);
  
  d2.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_d2);
  getT()->set_port_cb(5, &m_d2_nb_connector);
  
  d3.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_d3);
  getT()->set_port_cb(7, &m_d3_nb_connector);
  
  d4.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_d4);
  getT()->set_port_cb(9, &m_d4_nb_connector);
  
  d5.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_d5);
  getT()->set_port_cb(11, &m_d5_nb_connector);
  
  d0_entry.invalidate_direct_mem_ptr_cb.set(&d0, &d0_type::invalidate_direct_mem_ptr);

  d1_entry.invalidate_direct_mem_ptr_cb.set(&d1, &d1_type::invalidate_direct_mem_ptr);

  d2_entry.invalidate_direct_mem_ptr_cb.set(&d2, &d2_type::invalidate_direct_mem_ptr);

  d3_entry.invalidate_direct_mem_ptr_cb.set(&d3, &d3_type::invalidate_direct_mem_ptr);

  d4_entry.invalidate_direct_mem_ptr_cb.set(&d4, &d4_type::invalidate_direct_mem_ptr);

  d5_entry.invalidate_direct_mem_ptr_cb.set(&d5, &d5_type::invalidate_direct_mem_ptr);

  r0.invalidate_direct_mem_ptr_cb.set(&r0_entry, &r0_entry_type::invalidate_direct_mem_ptr);
  
  r1.invalidate_direct_mem_ptr_cb.set(&r1_entry, &r1_entry_type::invalidate_direct_mem_ptr);
  
  r2.invalidate_direct_mem_ptr_cb.set(&r2_entry, &r2_entry_type::invalidate_direct_mem_ptr);
  
  r3.invalidate_direct_mem_ptr_cb.set(&r3_entry, &r3_entry_type::invalidate_direct_mem_ptr);
  
  r4.invalidate_direct_mem_ptr_cb.set(&r4_entry, &r4_entry_type::invalidate_direct_mem_ptr);
  
  r5.invalidate_direct_mem_ptr_cb.set(&r5_entry, &r5_entry_type::invalidate_direct_mem_ptr);
  
  /* check mb_event policies */
  m_eth_t->check_mb_events();
}



void eth_pvt::b_transport_outside_r0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!r0.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << r0.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), r0.name());
    return;
  }
  r0.b_transport(p, t);
  
} 

unsigned int eth_pvt::transport_dbg_outside_r0(tlm::tlm_generic_payload& p)
{
  if (!r0.get_interface()) {
     return 0;
  }
  return r0.transport_dbg(p);
  
}

void eth_pvt::b_transport_outside_r1(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!r1.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << r1.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), r1.name());
    return;
  }
  r1.b_transport(p, t);
  
} 

unsigned int eth_pvt::transport_dbg_outside_r1(tlm::tlm_generic_payload& p)
{
  if (!r1.get_interface()) {
     return 0;
  }
  return r1.transport_dbg(p);
  
}

void eth_pvt::b_transport_outside_r2(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!r2.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << r2.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), r2.name());
    return;
  }
  r2.b_transport(p, t);
  
} 

unsigned int eth_pvt::transport_dbg_outside_r2(tlm::tlm_generic_payload& p)
{
  if (!r2.get_interface()) {
     return 0;
  }
  return r2.transport_dbg(p);
  
}

void eth_pvt::b_transport_outside_r3(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!r3.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << r3.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), r3.name());
    return;
  }
  r3.b_transport(p, t);
  
} 

unsigned int eth_pvt::transport_dbg_outside_r3(tlm::tlm_generic_payload& p)
{
  if (!r3.get_interface()) {
     return 0;
  }
  return r3.transport_dbg(p);
  
}

void eth_pvt::b_transport_outside_r4(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!r4.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << r4.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), r4.name());
    return;
  }
  r4.b_transport(p, t);
  
} 

unsigned int eth_pvt::transport_dbg_outside_r4(tlm::tlm_generic_payload& p)
{
  if (!r4.get_interface()) {
     return 0;
  }
  return r4.transport_dbg(p);
  
}

void eth_pvt::b_transport_outside_r5(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!r5.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << r5.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), r5.name());
    return;
  }
  r5.b_transport(p, t);
  
} 

unsigned int eth_pvt::transport_dbg_outside_r5(tlm::tlm_generic_payload& p)
{
  if (!r5.get_interface()) {
     return 0;
  }
  return r5.transport_dbg(p);
  
}

